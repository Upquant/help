{"./":{"url":"./","title":"优品量化","keywords":"","body":"优品量化平台 优品量化平台是优品财富旗下的一款多元资产量化交易平台，参考国外投行量化平台的设计模式，完全自主研发，专注于为专业投资者提供的可靠、高效的服务。优品量化以海量金融数据为基础，提供策略研发、回测、模拟交易和实盘交易等功能，支持股票、期货等多账户多品种的交易，为投资者打造一个专属的量化平台。 新手指引 :三分钟完成本地策略在优品量化平台回测全过程 平台介绍：深入了解优品量化平台，介绍平台整体架构、金融数据、量化引擎等 使用说明：开启量化之旅，详细介绍从SDK下载、策略研究到模拟实盘交易每一步 运行环境：支持C++和Python3.6，从截面了解平台交易撮合机制、交易引擎和业绩评价所用公式 API使用文档：介绍平台API使用方法，多维度数据处理，快速实现回测/交易 策略示例： 提供从入门到高阶各类经典策略示例，包括机器学习、网格、套利、多因子选股等策略 平台数据 ：一网打尽海量数据，支持tick、Level2 行情数据；财务数据及特色衍生金融数据 常见问题 ：关于优品量化、策略、回测、模拟交易等常见问题详尽解答 "},"guide1.html":{"url":"guide1.html","title":"新手指引","keywords":"","body":"新手指引 该新手教程为python版本SDK快速使用教程，建议在此之前为电脑准备python3.6环境，可使用Anaconda快速安装，点击此处下载Anaconda安装包。如需了解更多详细内容，请查看帮助文档中使用说明。 三分钟完成本地策略回测 以策略示例中 buySellFutures为例 。 1.前往官网下载优品sdk ；2.本地安装sdk ;3.打开本地example>-buySellFutures.py，配置策略示例中condfig信息，包括：user token strategy_name instance_id ;4.运行本地example>-buySellFutures.py策略文件，开始回测；5.在优品量化Web端查看策略回测结果； 三分钟完成本地策略回测-旧 以策略示例中 buySellFutures为例 。 1.前往官网下载优品sdk ；2.本地安装sdk ；3.打开本地example>-buySellFutures>-config，配置策略示例中condfig文件，包括：user token strategies name instance_id ；4.打开本地example>-buySellFutures>-main，运行main文件，开始回测；5.在优品量化Web端查看策略回测结果； "},"introduction2.html":{"url":"introduction2.html","title":"平台介绍","keywords":"","body":"平台介绍 整体架构 优品量化平台主要分为三个部分，WEB平台、SDK、量化引擎（用户不可见）。用户使用 SDK来完成策略编写，策略运行后和量化引擎服务通过网络通讯，最终的运行过程和结果都在WEB平台上展示。这几个模块间的通讯采用了异步事件实时通信机制，可以保证数据的准实时性，延时基本都可以控制在5ms左右。 平台的整体架构图如下: 优品量化平台重要的特点如下: （1）策略和引擎分离的模式, 策略在本地运行, 和云端引擎实时异步通讯来完成回测, 模拟, 实盘等操作, 保证了策略代码的绝对安全, 当然前提是要求本机安装优品量化平台的SDK;（2）底层采用c++来实现, 整体架构采取了全异步架构, 保证系统的高效率, 而SDK同时支持c++和python两种开发语言, 保证了策略开发的便利性;（3）整体架构采取全异步架构, 云端引擎完全模拟行情回放和撮合, 策略代码可以在回测, 模拟盘, 实盘间无缝迁移, 无须改动代码, 保证了逻辑的完全一致性;（4）策略运行中用到数据会自动拉取到本地, 并且会自动增量更新, 策略运行过程中会自动使用本地缓存数据 ,保证了获取数据的效率；（5）在资金利用率上，优品量化平台支持策略组合, 即一个账号下运行多个策略, 以提高资金的利用率;（6）优品量化平台在架构和协议上支持多元资产管理(A股,期货,基金等), 即一个策略能交易多种不同品种;（7）云端量化引擎支持实时风控, 可以实现账户粒度, 策略粒度的各级风控保护; 金融数据 数据作为量化的基础，对数据多样性、历史数据的准确性、实时数据的及时性是有严格要求的。优品量化提供包括以下数据： （1）近十年多品种(A股, 期货,)、多频率（Tick、分钟级、日线级）的历史数据（2）股票指数、行业板块的历史成分股数据（3）财务及相关指标数据（4）交易衍生指标数据 另外为了提高策略内获取数据的速度，用到的数据会通过SDK自动拉取到本地并缓存，后续使用会自动增量更新(策略无感知)。快速加载、极大的提高策略的运行速度。 量化引擎 在优品量化引擎中, 最核心的莫过于用户/仓位/订单/回测管理模块。这些模块都依托于核心的异步事件模块之上，共同构建了量化从回测、模拟盘到实盘的整体过程。 用户管理模块主要管理用户多市场账户、基本资产等信息。在设计上，一个用户下可以创建多个策略，策略共享用户的资金池，从而保证了资金利用率最大化。 仓位管理以行情为驱动，实时计算用户的仓位信息，用于实时风控等核心管理。设计上用户有整体仓位信息、盈亏信息，同时每个策略也有自己的盈亏信息，可以独立管理。 这种用户和仓位管理的设计模式能够更有效的组合策略，降低回撤，提高收益，实现真正的智能投顾。 订单模块主要用于管理下单、成交回报，订单在设计上最重要是考虑的下单安全性，避免策略出现异常，给资金带来极大的风险，因此订单模块做了如下机制: （1）内嵌订单状态机，保证同一标的同一方向同一时刻只能有一个挂单；（2）对于下单指令，统一通过SDK中指定仓位的方式来使用，不支持裸下单，订单模块会根据实际情况进行管理智能下单，保证挂单的正确性，并且后续完整的订单状态都会通知到SDK中；裸下单接口虽然直接，但是暴露出来的风险很难管理；（3）对于期货下单，同一标的同一时刻不允许相同价格两个方向的挂单，避免自成交；（4）通过以上机制来保证策略异常情况下，也不会发生同时下很多单的故障，最大限度保证资金安全。在设计上，回测模块其实相当于完整的封闭环境，内部包含了所有需要的模块，并且为了和实盘环境模拟一致，回测过程也是全异步的交互机制，从而保证策略回测代码能无缝迁移到模拟盘/实盘。另外回测完毕后会释放掉相关资源，提高资源利用率。 量化引擎在数据存储上也采用异步通知机制，所有订单/仓位等需要存储的信息都会异步写入到数据中，避免写IO阻塞正常请求，从而提升整体系统的性能。 sdk 针对策略开发者使用上，我们抛弃了传统客户端模式(要求使用者下载量化平台的PC客户端，安装后依托客户端写策略的模式)。 我们仅仅提供基本的SDK，通过异步网络通信机制和优品量化引擎进行交互，而数据又可以通过在web上实时管理。 这样设计虽然增加了整体系统的复杂度，但却大幅度降低了策略开发者的使用门槛，带来的好处却显而易见。 （1）策略开发可以在本地开发者自己的IDE上进行，最大程度保留了开发者的开发和调试习惯；（2）SDK目前支持Python/C++语言，在开发者本机运行， 如果希望使用深度学习/GPU等高级特性，就不存在任何障碍；（3）基于SDK实现的策略，在模拟盘(实盘)运行时可以分布到多机运行，而资金的管理和风控又可以集中在web上统一管理，甚至可以通过手机端来管理，对于专业的机构投资者来说极大的方便了整体策略的管理；（4）对于专业投资者，我们可以把优品核心的量化引擎通过docker方式部署在机构自己的服务器上；（5）SDK也提供了接口，可以让开发者将自己的数据源接入到SDK中(缓存在本地)，方便开发者使用。 web管理 Web管理是量化平台最重要的管理平台，主要包含了以下功能： （1）行情，可以直接在管理页面上关注股票实时接收行情；（2）手工下单买卖，必要时可以直接在管理平台上下单买卖；（3）创建回测、查看回测进度和回测结果；（4）创建模拟/实盘策略, 查看策略运行数据；（5）对策略和策略的参数管理；（6）用户和账户管理。 部署架构 对于普通用户，可以直接在用户自己的机器上，引用优品量化SDK实现策略并连接到优品量化云。如果要追求更快的速度可以联系我们，用户自己在阿里云/腾讯云上购买服务器，我们开放权限，通过阿里云/腾讯云内网进行连接速度会更快。 对于机构投资者，我们可以把优品量化引擎通过docker方式部署在机构的机器上，然后机构的策略连接自己的私有云即可。 在整体策略部署上，策略可以分布式部署，不同策略根据需要部署在不同机器上；对于机构投资者，可以把优品量化引擎也分布式部署在不同机器上，但是同一个账户都只能隶属于同一个优品量化引擎，可以通过web管理来配置账户的机器的对应关系。部署图如下： "},"operation3.html":{"url":"operation3.html","title":"使用说明","keywords":"","body":"使用说明 开启量化之旅 在本文档中，我们详细介绍了平台的各项功能和使用方法，也可以观看我们的新手入门视频教程熟悉量化平台。实现一个简单的本地策略主要有以下步骤： 序号 平台 步骤说明 1 本地 下载安装SDK 2 本地 编辑策略代码，对应具体策略执行逻辑 3 Web 对策略进行组合，创建回测或者运行实例。 4 本地 在策略文件中配置对应策略回测信息并运行策略 5 Web 在Web端查看回测报告 下面以Python为例对具体的操作步骤进行详细说明。 进入量化平台 首先打开量化官网，然后点击“登录”，会弹出登陆框，用户可以使用QQ、微信直接登录，也可以输入优品账号进行登录。 登录量化官网后点击“量化平台”，进入到我们的量化平台 进入量化平台后，会自动生成用于config中配置的user和token，点击自动生成的用户名会显示user和token，如下图所示 sdk下载 优品量化SDK提供多平台多语言支持。支持C++、python语言（建议使用python3.6，点击此处下载安装Anconda3-5.2.0，快速实现python3.6环境），以及Windows（64位）和Linux（64位）平台。 sdk解压 SDK下载解压后结构如下： SOMEPATH - example - BuySell-symbol -- 策略文件夹 - buySellSymbol.py --python策略程序文件 - sdk - etasdk-1.0.1546-py2.py3-none-win_amd64.whl --python包安装文件 安装python包 安装好python与pip后 在当前SDK文件夹路径处输入：cmd，回车，可直接打开当前路径命令提示符，如下图： 输入： pip install etasdk-1.0.1553-py2.py3-none-win_amd64.whl，回车，结果如下图： linux shell: [user@localhost~]$pip install ~/ SOMEPATH /sdk/etasdk-1.0.1546-py2.py3-none-win_amd64.whl sdk升级 SDK升级时，下载到新版本的SDK后，对*WHL文件直接进行安装即可。 文件说明 示例文件中config配置。(注：在策略中config配置或者单独config文件配置均可），各项意义如下： config = { \"host\": \"120.55.22.60\", \"port\": 80, \"user\" : \"SDK-User\", //Web端：点击量化平台右上角用户名可查看填写，登录地址： http://quant.upchina.com/quantstmall/main \"token\" : \"SDK-Token\", //Web端：点击量化平台右上角用户名可查看填写 \"strategy_name\": \"buySellSymbol\", # Web端：策略名称 \"console\": 0, \"loglevel\": \"ERROR\", # 显示日志级别，具体可查看帮助文档 # Web端：回测记录中本策略的回测ID,点击复制ID,粘贴此处即可 \"instance_id\": \"20190222-095421-222-002BI\", # 初始化参数 \"initialize\": { # symbols里设置单个股票或者其他有效的标的 # symbol_sets里设置标的集合，如此处的IF.PRD指的就是IF品种的所有标准合约，不包含IFZ0.CF和IFZ1.CF # 注：symbols和symbol_sets不能全部为空 'symbols': ['000001.CS'], # fields缓存的因子 'fields': ['FUT_TRADE_RANK', 'FUT_SHORT_RANK', 'FUT_LONG_RANK'], # 必填：设置所需k线类型，interval可以选取1分钟，5分钟，15分钟，30分钟，60分钟，日k，Tick级别，count为提前缓存的数目 'prepared_bars': [{'interval': ETimeSpan.DAY_1, 'count': 60}], # 选填：设置撮合参数 interval为撮合周期，time_ranges为日内撮合时间段，将只在指定时间段以interval周期回调on_bar或on_handle_date 'match_param': { 'interval': ETimeSpan.DAY_1, # 'time_ranges': [('12:00', '14:45'), ('10:10', '11:00')] }, 'mode': 'both', # 选填：为group_only，则只响应on_handle_data；为single_only，则只响应on_bar；为both，则两个回调同时响应 'commission': 0.0002, # 选填：设置手续费 # 选填：仅回测生效的项，不设置时以web页面上的设置为准 'backtest': { 'start_date': 20180702, # 回测开始日期 'end_date': 20181101, # 回测结束日期 'slippage': 1, # 设置滑点,取值为整数,标的价格浮动最小单位值的整数倍 # 设置账户初始资金 'cash': { 'CS': 1000000, # 设置股票账户资金 'CF': 0 # 设置期货账户资金 } }, # 选填：仅模拟盘/实盘生效的项 'realtime': { 'pre_market_time': '8:50', # 设置开盘前回调on_before_market_open响应事件时间，默认为web页面上设置的时间 'closing_time': '14:55', # 设置收盘前最后一次回调on_bar或on_handle_data响应事件时间，默认为web页面上设置的时间 'group_timeout': 10000, # 设置group模式下的组播，等待多少ms则强制响应，默认为5000ms 'timer_cycle': 60000 # 设置onTimer响应时间(ms), 为0则不响应onTimer，默认情况下不回调onTimer } } } 上述例子仅为单策略示例情况，如需使用多策略，可在config中修改如下配置,然后运行策略文件 config = { ... # \"strategy_name\": \"test\", # 策略名称 \"strategies\": [ { \"strategy\": \"test.py\",#策略文件 \"name\": \"test\" #策略名称 }, { \"strategy\": \"test1.py\", #策略文件 \"name\": \"test1\" #策略名称 }] ... } 策略研究 策略创建 策略创建包括两部分的操作：页面上策略管理和本地策略创建。 页面上策略管理 切换到策略管理tab可以对自己的策略进行管理，左侧是策略的列表，点击某个策略可以对其信息进行查看。策略名称是与本地代码中的配置进行对应的标识。点击新建策略按钮对策略进行创建，填写名称和说明、参数，参数分为两种，基础参数是指策略整体的参数，标的参数则是针对不同标的需要分别去设置的参数。调参是策略维护过程中一个非常重要的部分，用户可以直接在页面上设置策略参数，运行时动态调整而不用再去调整代码。 策略列表有三个按钮，分别是：复制策略到实盘（若已开通实盘则可复制成功）、复制策略到模拟盘、删除策略。 已有的策略也可以进行查看、编辑和删除。但是需要注意，策略若已在实例使用则不可删除。 本地策略创建 项目需要保持example的工程结构，可直接在example目录下修改或增加策略的python代码。注：本地仅做策略研究时，建议使用etadata调用数据，可获取更好的交互式编程环境体验。 系统支持多种事件函数，不同事件有不同触发时机和相关数据。详见API使用文档。 创建回测实例 创建回测实例是指填写策略回测参数，对一个或者多个策略创建与本地工程对应的实例。一个回测实例可以产生多条回测记录，每条回测记录有不同的回测ID来与本地的配置文件对应。 点击“创建实例”按钮，跳转到如下图界面。 填写实例名称，选择策略，修改策略参数，选择回测区间、设置撮合周期、费率、滑点、初始资金。 注意：选择回测区间，设置撮合周期、费率、滑点以及初始资金可在策略py文件中相应配置中设置更改，且策略文件中如果有设置则以策略文件为准，具体示例参考从一个简单的策略示例说起 参数说明如下： 参数 说明 回测区间 回测周期包含开始的时间、结束时间 撮合周期 on_bar或者on_tick函数的响应周期，包括日K、Tick、1分钟、5分钟、15分钟、30分钟、60分钟 费率 默认为2，单位为万分之 滑点 默认为1，单位为跳（最小价格变动单位） 初始资金 需要勾选市场，股票、期货均默认为1000000 当市场选择为股票，回测默认盘前时间为08:50，模拟盘自己设置不影响 当市场选择为期货，回测默认盘前时间为20:50，模拟盘自己设置不影响 当市场同时选择期货和股票，回测默认盘前时间以期货为准，模拟盘自己设置不影响 点击“保存实例”，跳转到回测页面，生成回测列表。若想生成多条回测记录，则可以点击新建回测增加。 运行回测 用户创建的本地策略需要与Web进行连接。以Web页面策略名称为buySellFutures，本地的策略文件以buySellFutures.py为例，需要在策略文件config中配置包括：user token strategy_name instance_id 。 查看回测结果 回测详情可以在页面进行查看，包括收益概况，每日持仓，每日平仓，交易详情，标的统计，阶段统计，模块参数，日志等，以及运行本次策略的参数设置。回测完成后可以导出回测结果的相关数据，如：交易详情、收益权益概况、每日持仓和每日平仓以及标的统计的数据。实例可以修改后再次回测。 编辑回测：可以修改相关参数，并填写此次回测备注信息以介绍此次回测相关内容(注：除模块参数外，如果回测参数在本地策略文件中已经设置,则以本地策略文件设置为准) 模拟交易 模拟交易策略管理 用户需要对模拟交易和策略研究的策略分别进行管理。可以拷贝策略研究中的策略到模拟交易中。 创建模拟交易运行实例 点击“创建实例”按钮，跳转到如下图界面对模拟交易运行实例进行创建。 填写实例名称、开盘前onBeforeMarketOpen的响应时间、收盘前日Kbar的返回时间，选择策略、修改策略参数、选择撮合周期，点击“保存实例”，跳转到策略运行页面。如下图： 模拟交易的策略运行页面可查看模拟交易的实例收益情况及运行状态。 未连接：需要将模拟交易实例ID，复制到本地代码配置文件config中，运行本地策略即可连接； 已连接：实例已连接平台模拟交易，依据实盘交易规则模拟运行。 已断开：代码运行过，现已断开。 模拟运行实例 用户创建的本地策略需要与本地进行连接。直接复制回测ID到本地策略文件中config下的\"instance_id\"处。以页面策略名称为test，本地的策略代码以s_custome.py为例，相关配置如下： config = { ... \"strategy_name\": \"test\", # 策略名称 “instance_id”:” 20180928-111030-678-001S” //模拟运行时的实例ID 查看模拟运行详情 点击实例卡片进入实例详情页面，如下图： 遇到特殊情况，可在交易时间段内选择一键平仓（如策略同时包括股票、期货，必须同时都满足为交易时间段，方可执行一键平仓），请谨慎使用 模拟运行中调参 模块参数在运行中可以进行调整，根据不同的市场行情，可以选择启用/停用已选择的策略，模块参数也能在页面中直接进行修改，不用去修改代码。 如图中所示，可点击 策略参数-->编辑，调整初始资金，点击保存。参数修改成功。 模拟运行中手动下单 模拟交易实例满足交易时间内手动下单调仓。界面如下图所示： 注意：股票只满足多方操作。委托的仓位为您所需的目标仓位。 模拟运行中盘前挂单 模拟交易实例满足非交易时间内盘前挂单，盘中撮合。界面如图所示： 注意：盘前挂单只在非交易时间段内（如A股在9:30之前以及11:30~13:00之间）可挂单，撤销等操作。交易时间段内撮合。 查看模拟账户 点击“账户”，显示该用户所有账户的收益情况、开平仓明细和订单明细。 风控管理 风控管理分为账户风控和实例风控。账户风控有账户指标风控和账户级别的合约风控；实例风控有实例指标风控和实例级别的合约风控。风控创建好后需要手动点击开启按钮才会开启。 实盘交易 创建实盘交易运行实例 操作与模拟交易一致，先创建策略或者通过拷贝策略研究中的策略到实盘交易中，然后点击“创建实例”按钮，跳转到如下图界面对实盘交易运行实例进行创建。填写实例名称、开盘前onBeforeMarketOpen的响应时间、收盘前日Kbar的返回时间，选择策略、修改策略参数、选择撮合周期。 点击“保存实例”，跳转到策略运行页面。如下图： 实盘交易的策略运行页面可查看实盘交易的实例收益情况及运行状态。 未连接：需要将实盘交易实例ID，复制到本地代码找到相应的配置\"instance_id\"处粘贴，运行本地策略即可连接； 已连接：实例已连接平台实盘交易； 已断开：代码运行过，现已断开。 实盘运行实例 同模拟交易一样，用户创建的本地策略需要与本地进行连接。直接复制回测ID到本地策略文件中config下的\"instance_id\"处。以页面策略名称为test，本地的策略代码以s_custome.py为例。，相关配置如下。 config = { ... \"strategy_name\": \"s_custome\", # 策略名称 “instance_id”:” 20181219-152331-967-001SR” //实例ID 查看实盘运行详情 点击“实例卡片进入实例详情页面，如下图： 遇到特殊情况，可在交易时间段内选择一键平仓（如策略同时包括股票、期货，必须同时都满足为交易时间段，方可执行一键平仓），请谨慎使用 实盘运行中调参 模块参数在运行中可以进行调整，根据不同的市场行情，可以选择启用/停用已选择的策略，模块参数也能在页面中直接进行修改，不用去修改代码。 如图中所示，可点击 策略参数-->编辑，调整初始资金，点击保存。参数修改成功。 实盘运行中手动下单 实盘交易实例满足交易时间内手动下单调仓。界面如下图所示： 注意股票只满足多方操作。委托的仓位为您所需的目标仓位。 实盘运行中盘前挂单 实盘交易实例满足非交易时间段内挂单，盘中撮合。界面如下图所示： 注意盘前挂单只在非交易时间段内（如A股在9:30之前以及11:30~13:00之间）可挂单，撤销等操作。交易时间段内撮合。 查看实盘账户 点击“账户”，显示该用户所有账户的收益情况、开平仓明细和订单明细。 如需开通实盘交易服务，请联系我们（QQ群：648583092）。 实盘风控管理 风控管理分为账户风控和实例风控。账户风控有账户指标风控和账户级别的合约风控；实例风控有实例指标风控和实例级别的合约风控。风控创建好后需要手动点击开启按钮才会开启。 "},"runtime4.html":{"url":"runtime4.html","title":"运行环境","keywords":"","body":"运行环境 支持语言及所需模块 平台目前支持C++及Python语言，Python支持的版本为Python3.6。 Python版本的SDK运行，需要安装的基础模块有：six1.11.0及以上版本、addict1.0.0及以上版本、pandas。建议安装Anaconda（点击此处下载安装Anconda3-5.2.0，快速实现python3.6环境）已包含相关的第三方库。 行情订阅 平台提供实时行情和历史行情。目前平台支持的行情频率有tick、1分钟、5分钟、15分钟、30分钟、60分钟、日线级。A股数据目前不支持tick级。 如需使用Tick数据，请联系我们：请联系我们（QQ群：648583092） 对于实时行情，分钟级和日线数据在on_bar/on_handle_data内进行触发。在创建回测或者运行实例的时候可以选择回调函数响应的周期。 对于历史行情，可以通过API进行调用。在创建回测或者运行实例的时候选择要用到的数据频率，可以订阅多种周期。也可以自行选择行情数据的复权模式。 目前提供的历史数据如下： A股： 频率 历史数据区间 日线级 2011年1月1日起至今 分钟级 2015年1月1日起至今 期货： 频率 历史数据区间 tick级 2017年10月9日起至今 分钟级 2015年1月1日起至今 日线级 2011年1月1日起至今 撮合机制 回测环境 【市价单】 按天回测：若在开盘前下单，则采用当天的开盘价下单；若在on_bar函数中下单则采用当天的收盘价下单。 分钟回测：若在开盘前下单，则采用当天的开盘价下单；若在on_bar函数中下单则采用这根bar的收盘价下单。 Tick回测：以当前tick买价卖，以当前tick卖价买。 【限价单】 以委托价进行挂单。 按天回测目前不支持限价单。 分钟回测按照该分钟bar的close进行撮合，若不成交，则挂单之后每分钟均按分钟bar的close撮合，未成交部分顺延至下一分钟进行撮合，直到完全成交或者当天收盘为止。 按tick下单之后，若不是立即成交，则根据每个tick数据的对手价撮合成交，直到成交或收盘为止。 上述过程中若实际价格已经涨停或者跌停，则买单或卖单不成交，相应的市价单直接取消，限价单会挂单直到可以成交。一天结束后，所有未成交的订单会被取消。 交易环境 在开盘前下的单都会以当日的第一根行情价格进行撮合成交。盘中挂单都会以tick进行实时撮合，只是由于on_bar的响应频率不同导致策略逻辑执行的周期不同。 【市价单】 按天交易：可以选择日K距离收盘几分钟进行返回，以这根返回的bar的close后的最新行情价进行下单撮合，不成交或未成交部分即刻取消委托。 按分钟交易：当前分钟bar结束后的现价撮合。忽略最后每个交易日最后一个bar。 【限价单】 挂单后会以最新行情进行撮合，若不成交，则每个tick都进行撮合直至成交或收盘。 交易引擎 交易税费 在回测时可以设置交易税费，默认为0，单位为万分之。 滑点 采取N个最小变动价格单位的形式来设置滑点，1个单位代表一跳。滑点设置后，买入价格调整为 价格+滑点跳数的价格；卖出价格调整为 价格-滑点跳数的价格。 执行时间 onBeforeMarketOpen的执行时间在开盘前，具体时间可以由用户根据自己策略的复杂度自行设置。 onTick、onBar函数则是在收到对应行情时触发，每个标的都会触发一次回调函数。 交易环境下日k的收取 在交易环境，一般情况下当日K收到时当日的交易时段已经结束。为了能让用户在收盘前有处理的时间，可以对日K收取的时间进行设置，例如设置股票市场提前3分钟收取日K，则在14:57分的时候就可以收到当天的日K。 除权除息 当股票发生分红拆分时，股价会发生变化，往往在股价走势图上出现向下的跳空缺口。在回测部分我们默认提供不复权的数据，用户可以利用我们提供的复权因子数据自行计算除权除息，系统会在回测时自动处理好除权除息的问题，计算对应的价格和数量。若需要获取历史的数据，我们提供了获取前复权数据的API来保证数据的平滑。 期货连续合约跳空 对于期货数据的连续合约，由于换合约导致的跳空，也采用前复权的方式来进行处理。 期货交割日处理 期货持仓到交割日若没有手动交割，系统会以当天结算价平仓。 业绩评价 策略收益率 策略收益率表示策略回测区间的收益率，计算公式如下： 基准收益率 基准收益率表示基准在策略回测区间的收益率，一般默认沪深300为基准，计算公式如下： 策略年化收益率 策略年化收益表示回测区间内策略的复合年化收益率，计算公式如下： 策略收益波动率 策略收益波动率是用来测量策略的风险性的，其值越大表示风险越大，计算公式如下： 夏普比率 夏普率表示每承受一单位总风险所获得的超额报酬，计算公式如下： 平仓胜率 用户平仓胜率等于平仓盈利的次数除以总的平仓次数。 最大回撤 最大回撤用来描述策略可能出现的最糟糕的情况，计算公式如下： "},"api5.html":{"url":"api5.html","title":"API使用文档","keywords":"","body":"API使用文档 从一个简单的策略示例说起 与其他纯web端的量化平台相比，本平台提供的方式支持本地化代码，因此在初始化阶段，比其他平台稍微多了数据缓存的初始化流程。相对于这一点点繁琐，我们可以保证任何代码都不用提交到平台，更能保证策略的私密性， 一个典型的策略代码需要包含以下事件函数的实现，完整的例子可以直接看安装包下example文件夹中的BuySell-future。 引入etasdk量化策略库 from etasdk import * if __name__ == '__main__': # 读取配置文件并启动策略 bar_span = ETimeSpan.DAY_1 config = { \"host\" : \"120.55.22.60\", \"port\" : 80, \"user\" : \"SDK-User\", # Web端：点击量化平台右上角用户名可查看填写 \"token\" : \"SDK-Token\", # Web端：点击量化平台右上角用户名可查看填写 \"strategy_name\": \"test\", # 策略名称 \"console\" : 0, \"loglevel\" : \"ERROR\", # 显示日志级别，具体可查看帮助文档 # Web端：回测记录中本策略的回测ID,点击复制ID,粘贴此处即可 \"instance_id\" : \"20180530-163657-609-001BI\", # 初始化参数 \"initialize\": { # symbols里设置单个股票或者其他有效的标的 # symbol_sets里设置标的集合，如此处的IF.PRD指的就是IF品种的所有标准合约，不包含IFZ0.CF和IFZ1.CF # 注：symbols和symbol_sets不能全部为空 'symbols': ['IFZ0.CF'], 'symbol_sets': ['IF.PRD', 'CF.PRD', 'IC.PRD'], # fields缓存的因子 'fields': ['FUT_TRADE_RANK', 'FUT_SHORT_RANK', 'FUT_LONG_RANK', 'STK_HOLD_DET', 'STK_HOLD_STAT', 'ST_STA','LIST_STA', 'TRADE_STA', 'NET_PROFIT', 'PB', 'PE', 'PS', 'PE_TTM'], # 必填：设置所需k线类型，interval可以选取1分钟，5分钟，15分钟，30分钟，60分钟，日k，Tick级别，count为提前缓存的数目 'prepared_bars': [ {'interval': bar_span, 'count': 1} ], # 选填：设置撮合参数 interval为撮合周期，time_ranges为日内撮合时间段，将只在指定时间段以interval周期回调on_bar或on_handle_date 'match_param': { 'interval': bar_span, # 'time_ranges': [('12:00', '14:45'), ('10:10', '11:00')] }, # 选填：为group_only，则只响应on_handle_data；为single_only，则只响应on_bar；为both，则两个回调同时响应 'mode': 'group_only', # 选填：设置手续费 'commission': 0.0002, # 选填：仅回测生效的项，不设置时以web页面上的设置为准 'backtest': { # 回测开始日期 'start_date': 20190101, # 回测结束日期 'end_date': 20190104, # 设置滑点,取值为整数,标的价格浮动最小单位值的整数倍 'slippage': 2, # 设置账户初始资金 'cash': { # 设置A股资金 'CS': 0, # 设置期货资金 'CF': 11000000 } }, # 选填：仅模拟盘/实盘生效的项 'realtime': { # 设置开盘前回调on_before_market_open响应事件时间，默认为web页面上设置的时间 'pre_market_time': '19:00', # 设置收盘前最后一次回调on_bar或on_handle_data响应事件时间，默认为web页面上设置的时间 'closing_time': '14:55', # 设置group模式下的组播，等待多少ms则强制响应，默认为5000ms 'group_timeout': 10000, # 设置onTimer响应时间(ms), 为0则不响应onTimer，默认情况下不回调onTimer 'timer_cycle': 60000 } } } etasdk.load_config_json(config).start() 系统初始化事件 必要：作为系统进入状态前设置必要的参数，包括自定义参数和系统预设参数，如在config配置中已设置初始化参数initialize则不需要再调用def on_initialize(api)函数，如config中未设置，则可参考如下示例设置。 def on_initialize(api): \"\"\" 初始化 :param api: :return: \"\"\" api.bar_span = ETimeSpan.DAY_1 # 自定义变量，代表撮合周期 # api.bar_span = ETimeSpan.MIN_5 # 自定义变量，代表撮合周期 api.context.init = { # symbols里设置单个股票或者其他有效的标的 # symbol_sets里设置标的集合，如此处的IF.PRD指的就是IF品种的所有标准合约，不包含IFZ0.CF和IFZ1.CF # 注：symbols和instsets不能全部为空 # 'symbols': ['IFZ0.CF'], 'symbols': ['000001.CS'], 'symbol_sets': ['IF.PRD'], # fields缓存的因子, 'fields': ['PE', 'PS', 'FUT_TRADE_RANK','TRADE_STA'], # 必填：设置所需k线类型，interval可以选取1分钟，5分钟，15分钟，30分钟，60分钟，日k，Tick级别，count为提前缓存的数目 'prepared_bars': [ {'interval': api.bar_span, 'count': 100} ], # 选填：设置撮合参数 interval为撮合周期，time_ranges为日内撮合时间段，将只在指定时间段以interval周期回调on_bar或on_handle_date 'match_param': { 'interval': api.bar_span, # 'time_ranges': [('12:00', '14:45'), ('10:10', '11:00')] }, # 选填：为group_only，则只响应on_handle_data；为single_only，则只响应on_bar；为both，则两个回调同时响应 'mode': 'group_only', # 选填：设置手续费 'commission': 0.0002, # 选填：仅回测生效的项，不设置时以web页面上的设置为准 'backtest': { # 回测开始日期 'start_date': 20181124, # 回测结束日期 'end_date': 20190101, # 设置滑点,取值为整数,标的价格浮动最小单位值的整数倍 'slippage': 2, # 设置账户初始资金 'cash': { # 设置A股资金 'CS': 5000000, # 设置期货资金 'CF': 11000000 } }, # 选填：仅模拟盘/实盘生效的项 'realtime': { # 设置开盘前回调on_before_market_open响应事件时间，默认为web页面上设置的时间 # 'pre_market_time': '20:00', # 设置收盘前最后一次回调on_bar或on_handle_data响应事件时间，默认为web页面上设置的时间 # 'closing_time': '14:55', # 设置group模式下的组播，等待多少ms则强制响应，默认为5000ms 'group_timeout': 10000, # 设置onTimer响应时间(ms), 为0则不响应onTimer，默认情况下不回调onTimer 'timer_cycle': 60000 } } 盘前事件 必要：每个交易日回测/模拟/实盘前要做的操作，选标的和进行盘前下单操作，必须实现！ def on_before_market_open(api, time): \"\"\" 必要：每个交易日回测/模拟/实盘前需要响应的事件 :param api: :param trade_now: :return: \"\"\" api.futures_code = api.get_continuous_symbol(\"IFZ0.CF\") # 获得当前交易日IF主力合约代码 api.context.pool.focus = [api.futures_code, 'IFZ0.CF'] 盘中事件 根据初始化参数来选择响应on_bar和on_handle_data，此处初始化使用的是group_only模式，则只响应on_handle_data # on_bar每一个Focus标的对应的k线到时间都会响应 def on_bar(api, bar): ... # on_handle_data在关注的所有标的都可以响应时或者超时时响应 def on_handle_data(api, time): trade_now = api.context.time.trade_now symbol_positions = api.context.strategy.positions # 获取持仓标的信息 bars = api.context.bar[api.futures_code] # 获得合约当前bar数据 factor = bars['preClose'] / bars['open'] # 当前开盘价与昨日收盘价之比 # print(factor) if symbol_positions: # 如果有持仓 if api.futures_code == symbol_positions[0].symbol: # 当前持仓为主力合约 # 止盈5% 止损3% if symbol_positions[0].posHigh / symbol_positions[0].posPrice > 1.05 \\ or symbol_positions[0].posLow / symbol_positions[0].posPrice 系统终止事件-回测 回测状态下，系统最后会将回测结果在这里输出 #运行终止调用 def on_terminate(api, exit_info): # 存入回测结果 api.save_object(exit_info) 小结 至此，一个简单的期货买卖策略就介绍完毕了，接下来将要了解本平台提供的各种接口和参数，以便写出自己的策略代码。 深度理解api-必看 主要问题 为了高效的使用API, 需要对平台的机制有一定的了解. 优品量化的平台最核心的特点是SDK模式, 本机安装SDK后, 策略基于SDK实现, 和云端量化引擎通讯来完成策略的运行, 同时策略运行过程中, 数据也需要自动的从云端拉取到本地. 那么为了保证策略运行的高效性, 就需要考虑如下几个问题: 这么大量的数据, 如何保证拉取数据的效率? 策略运行过程中, 播放K线时如果保证效率? 为了解决这两个问题, API提供了相关机制来控制和优化效率: 设置数据 在initialize中设置需要的数据: 个股, 标的池(市场, 板块,期货品种等) K线类型和历史根数 A股各类因子#设置股票池、相关标的因子数据和K线。 'symbols': [\"IFZ0.CF\",\"000001.CS\"], 'symbol_sets': [\"000016.IDX\",\"cu.PRD\"], 'fields': [\"CIRC_CAP\", \"TURNOVER_RATE\", \"PE\"], 'prepared_bars': [{'interval': bar_span, 'count': 1}], #设置股票池、相关标的因子数据和K线。 'symbol_sets': [\"000016.IDX\",\"cu.PRD\"], 'fields': [\"CIRC_CAP\", \"TURNOVER_RATE\", \"PE\"], 'prepared_bars': [{'interval': bar_span, 'count': 1}], #设置股票池、相关标的因子数据和K线。 'symbols': [\"IFZ0.CF\",\"000001.CS\"], 'fields': [\"CIRC_CAP\", \"TURNOVER_RATE\", \"PE\"], 'prepared_bars': [{'interval': bar_span, 'count': 1}], #设置股票池和K线。 'symbols': [\"IFZ0.CF\",\"000001.CS\"], 'symbol_sets': [\"000016.IDX\",\"cu.PRD\"], 'prepared_bars': [{'interval': bar_span, 'count': 1}], #设置股票池和相关标的因子数据 'symbol_sets': [\"000016.IDX\",\"cu.PRD\"], 'symbols': [\"IFZ0.CF\",\"000001.CS\"], 'fields': [\"CIRC_CAP\", \"TURNOVER_RATE\", \"PE\"] initialize在策略启动后只会调用一次, 在策略运行过程中, 只会拉取相关的数据. 因此在实现策略过程中, 尽量只设置自己需要的数据, 避免拉取太多数据, 这有助于提高策略运行的性能. 减少K线播放量 策略运行过程中, 云端量化引擎会播放相应的K线来驱动策略运行.SDK中的on_before_market_open每个交易日开盘前会响应一次, 策略可以在这个函数中执行选股逻辑, 然后调用set_focus_symbols来关注选出来的标的. 注意: 只有set_focus_symbols的股票以及持仓的标的才会收到当天的行情推送. 比如:在initialize中,设置了A股全市场(CS.SET), 但是每天选股过程中只会选取几只股票, 并对这几只股票做买卖操作, 因此只需要set_focus_symbols这几只股票, 从而大幅度提升了效率. K线的三种播放机制 on_handle_data模式: on_before_market_open中focus了多少标的, 都只会回调on_handle_data一次. on_bar模式: on_before_market_open中set_focus_symbols的标的+持仓标的, 每个标的都会收到on_bar的回调, 比如set_focus_symbols标的+持仓标的有10只, 播放是日K行情, 那么当天on_bar会有10次回调; on_handle_data/on_bar混合的both模式: 两者都会回调 initialize中通过调用mode来控制播放模式, 默认不设置mode则是on_bar模式 #设置只响应on_handle_data，超时时间为5000ms 'mode': 'group_only', ... 'group_timeout': 5000, #设置既响应on_handle_data，也响应on_bar，超时时间为10000ms 'mode': 'both', ... 'group_timeout': 10000, group_timeout用于在模拟盘/实盘情况下, 如果超过group_timeout, 相应的K线还没有到齐, 则不再等待, 直接回调on_handle_data. 内置数据结构 RefData-股票基础信息 属性 类型 说明 symbol str 标的代码。 marketName str 品种名称。CS-股票；CF-期货；IDX-指数。 exchange str 交易所及自定义类型后缀。SZ-深交所；SH上交所；DCE-大商所；SHFE-上期所；CZCE-郑商所；CFFEX-中金所；PLATE-板块；SET-证券集合。 currency str 币种。 lotSize double 一手标的的数目。 name str 标的名称。 tplus int T+N交易。例如tplus为1时为t+1交易。 marginRate double 保证金比例。 shortSellable bool 是否可卖空。 valuePerUnit double 合约乘数 priceTick double 标的价格浮动最小单位值 exchSymbol str 交易所的原始symbol isStandard bool 是否是交易所的标准合约，比如主力合约 IFZ0.CF 就不是交易所的标准合约 tradeMarket str 该标的对应的交易市场，目前仅有 CS CF listDate int 上市日，无则为0。 lastTradeDate int 最后交易日(退市日)，无则为0。 Tick-Tick行情信息 属性 类型 说明 symbol str 标的代码。 bid double 买一价。 ask double 卖一价。 bidVol double 买一量。（单位为实际证券股数） askVol double 卖一量。 last double 最新成交价。 lastVolume double 最新成交量。 lastTurnover double 最新成交额。 totalVolume double 交易日总成交量。 totalTurnover double 交易日总成交额。 high double 交易日最高价。 low double 交易日最低价。 open double 交易日开盘价。 close double 交易日收盘价。 tradeDate long 交易日-年月日，格式为YYYYMMDD timeExch long 交易所的实时时间戳-年月日时分秒 (ms)， timeStr str 交易时间，格式为YYYYMMDD-hhmmss-xxx bids vector 五档买价，包括数量和价格，qtyprice{\"quantity\":qty,\"price\":price}。 asks vector 五档卖价，包括数量和价格。 ceil double 涨停价。 floor double 跌停价。 position double 持仓量(期货)。 preClose double 昨日收盘价。 preSettle double 昨日结算价。 Bar-Bar数据信息 属性 类型 说明 symbol str 标的代码。 tradeDate long 交易日-年月日，格式为YYYYMMDD timeStop long bar对应的截止时间戳 (ms) timeStr str 交易时间，格式为YYYYMMDD-hhmmss-xxx timeSpan long K线的时间频率。 high double 交易日最高价。 low double 交易日最低价。 open double 交易日开盘价。 close double 交易日收盘价。 volume double KBar成交量。 turnover double KBar成交额。 totalVolume double 交易日总成交量。 totalTurnover double 交易日总成交额。 preClose double 昨日收盘价。 settle double 结算价。 preSettle double 昨结。 position double 持仓量。 isSuspended bool 是否停牌。 SymbolPosition-策略的标的持仓 某一个策略中某只标的的仓位信息。 属性 类型 说明 symbol str 标的代码。 positionSide PositionSide 持仓方向。 posQty double 持仓数量，不包括挂单的仓位。 posDailyQty double 当日开仓的持仓数量，不包括挂单的仓位。 posPrice double 持仓均价。 posHigh double 持仓以来最高价。 posLow double 持仓以来最低价。 posTime long 开仓时间（时间戳）。 posUrPnL double 仓位总浮动盈亏。 availableQty double 今日可平仓数量。 posDailyOverallPnL double 当日盈亏=当日浮动盈亏+当日平仓盈亏，结算时清零。 posTradeDate int 开仓交易日，格式为YYYYMMDD。 posMargin double 仓位占用保证金。 posMarketValue double 仓位市值。 StrategyPnL-策略的盈亏信息 策略的整体盈亏信息。 属性 类型 说明 id double 策略ID。 urPnL double 策略的总浮动盈亏。 overallPnL double 策略的整体总盈亏，包含平仓盈亏。 dailyPnL double 策略的当日盈亏=当日浮动盈亏+当日平仓盈亏，结算时清零。 totalCommission double 策略总手续费 OverallPosition-账户的标的持仓 由于多个策略可以共享账户资金，因此可能会存在多个策略中都持有某个标的的情况，账户中会将多个策略中标的信息进行汇总。 属性 类型 说明 accountId str 账户ID。 symbol str 标的代码。 buyPrice double 加权平均买价。 sellPrice double 加权平均卖价。 buyQty double 买数量。 sellQty double 卖数量。 longQty double 多仓持仓数量。 shortQty double 空仓持仓数量。 longPrice double 多仓持仓均价。 shortPrice double 空仓持仓均价。 longLastUrPnL double 多仓浮动盈亏。 shortLastUrPnL double 空仓浮动盈亏。 lastUrPnL double 总持仓总浮动盈亏。 longAvailableQty double 多仓可平仓数量。 shortAvailableQty double 空仓可平仓数量。 longMargin double 多仓占用保证金。 shortMargin double 空仓占用保证金。 longMarketValue double 多仓持仓市值。 shortMarketValue double 空仓持仓市值。 Account-账户信息 属性 类型 说明 id str 账户ID。 market str 市场。 currency str 账户币种。 dailyPnL double 当日盈亏=当日浮动盈亏+当日平仓盈亏，结算时清零。 urLastPnL double 浮动盈亏。 allTimePnL double 平仓盈亏。 cashDeposited double 累积出入金。 cashAvailable double 可用现金。 unitValue double 账户基金净值。 bonus double 现金分红。 margin double 持仓占用资金。 marketValue double 持仓市值。 totAssets double 总资产。 totalCommission double 总手续费。 Order-订单委托信息 属性 类型 说明 symbol string 标的代码。 side EOrderSide 买卖方向。 positionSide EPositionSide 订单持仓方向。 positionEffect EPositionEffect 订单开平仓类型。 qty double 委托量。 price double 委托价。 userId string 用户id。 accountId string 账户id。 created long 委托创建日期。 id string 订单id。 tradeDate int 交易日。 strategyId string 所属策略id。 portfolioId string 组合id。 commission commission 手续费。 tradeAccount string 交易账号。 externalOrderId string SDK生成的ID-SDK。 orderType EOrderType 订单委托类型，市价或限价单。 ordStatus EOrdStatus 订单状态。 cumQty double 已成量。 avgPx double 已成均价。 tif TimeInForce 订单时间状态。 modified long 委托最后修改日期。 execType EExecType 订单执行状态。 EtaTime-时间信息 属性 类型 说明 year int 年 month int 月 day int 日 hour int 时 minute int 分 second int 秒 week int 周 weekday int 星期 0-6 代表星期一-星期日 date int YYYYmmdd now EtaTime 当前时间，回测则为回测当前时间 trade_now EtaTime 当前交易日，回测则为回测当前交易日 内置向前取交易日函数： get_prev_trade_dates(market='CS', count=None, start=None, period=('D', 1)) 示例： nowdate = EtaTime.trade_now print(nowdate.get_prev_trade_dates().date) # 20180103 print(nowdate.get_prev_trade_dates(count=2)) # list[EtaTime] print(nowdate.get_prev_trade_dates(start=20171225)) # list[EtaTime] 内置枚举类型 内置枚举类型的取用方式为enumClass.enum，例如：tick级别的频率类型，ETimeSpan.TICK ETimeSpan-频率类型 enum ETimeSpan { TICK, //tick类型 MIN_1, //1分钟K线 MIN_5, //5分钟K线 MIN_15, //15分钟K线 MIN_30, //30分钟K线 MIN_60, //60分钟K线 DAY_1, //日K线 }; EPriceMode-复权模式 enum EPriceMode { REAL, //不复权 FORMER, //前复权 }; EPositionSide-持仓方向 enum EPositionSide { LONG = 1, //多仓 SHORT = 2, //空仓 }; EOrderSide-买卖方向 enum EOrderSide { BUY = 1, //买入 SELL = 2,//卖出 }; EOrderType-订单类型 enum EOrderType { MARKET = 1, //市价单 LIMIT = 2, //限价单 }; EOrdStatus-订单状态 enum EOrdStatus { NONE = 0, NEW = 1, //新单 PARTIALLY_FILLED=2, //部分成交 FILLED= 3, //全部成交 DONE_FOR_DAY=4, //今日完结 CANCELED=5, //撤销 REPLACED=6, //修改 PENDING_CANCEL=7, //正在撤销 STOPPED=8, //终止 REJECTED=9, //拒绝 SUSPENDED=10, //挂起 PENDING_NEW=11, //正在创建 CALCULATED=12, //正在计算 EXPIRED=13, //过期 ACCEPTED_FOR_BIDDING=14, //正在接受交易 PENDING_REPLACE=15, //正在修改 }; EExecType-订单执行状态 enum EExecType { NONE = 0, NEW = 1, //新单 PARTIALLY_FILLED=2, //部分成交 FILLED= 3, //全部成交 DONE_FOR_DAY=4, //今日完结 CANCELED=5, //撤销 REPLACED=6, //修改 PENDING_CANCEL=7, //正在撤销 STOPPED=8, //终止 REJECTED=9, //拒绝 SUSPENDED=10, //挂起 PENDING_NEW=11, //正在创建 CALCULATED=12, //正在计算 EXPIRED=13, //过期 ACCEPTED_FOR_BIDDING=14, //正在接受交易 PENDING_REPLACE=15, //正在修改 }; ETimeInForce-订单委托属性 enum ETimeInForce { NONE = 0, //未指定，如果不指定;则限价单默认为DAY,市价单默认为 IMMEDIATE_OR_CANCEL DAY = 1, //订单在交易日内有效，会自动取消 GOOD_TILL_CANCEL = 2, //暂时不支持—订单一直有效，直到投资者主动撤销订单（一般也有默认有效期30~90天） AT_THE_OPENING = 3, //暂时不支持-订单在开市的时候被执行，如果开盘内不能执行，则取消；通常是开盘前集合竞价或者开盘前的瞬间 IMMEDIATE_OR_CANCEL = 4, //订单必须立即执行，不能被立即执行的部分将被取消 FILL_OR_KILL = 5, //订单必须被完全执行或者完全不执行 GOOD_TILL_CROSSING = 6, //暂时不支持- GOOD_TILL_DATE = 7, //暂时不支持-订单一直有效，直到指定日期 AT_THE_CLOSE = 8, //暂时不支持-订单在交易最后执行（或者尽可能接近收盘价），通常是收拾撮合的时间段 }; EtaPriceList-报价列表 enum EtaPriceList { EPriceList.NONE = 0, EPriceList.BID1 = 1, //买一价 EPriceList.BID2 = 2, //买二价 EPriceList.BID3 = 3, //买三价 EPriceList.BID4 = 4, //买四价 EPriceList.BID5 = 5, //买五价 EPriceList.BID6 = 6, //买六价 EPriceList.BID7 = 7, //买七价 EPriceList.BID8 = 8, //买八价 EPriceList.BID9 = 9, //买九价 EPriceList.BID10 = 10, //买十价 EPriceList.ASK1 = 101, //卖一价 EPriceList.ASK2 = 102, //卖二价 EPriceList.ASK3 = 103, //卖三价 EPriceList.ASK4 = 104, //卖四价 EPriceList.ASK5 = 105, //卖五价 EPriceList.ASK6 = 106, //卖六价 EPriceList.ASK7 = 107, //卖七价 EPriceList.ASK8 = 108, //卖八价 EPriceList.ASK9 = 109, //卖九价 EPriceList.ASK10 = 110, //卖十价 }; 需要实现的事件 on_initialize(api)-初始化 函数示例： def on_initialize(api): api.context.init = { ... } 说明： 在策略运行前会调用一次，用来进行初始化各项运行参数,如config配置中已有initialize配置，则此步骤可省略。 on_before_market_open(api, trade_date)-盘前运行 函数示例： def on_before_market_open(api, trade_date): print(trade_date) # 20180103 api.context.focus = ['IFZ0.CF'] # 设置关注的股票 说明： trade_date表示当前日期，开盘前调用一次，选股的逻辑可以在这个函数中实现，你可以根据策略的复杂度在创建实例时设置其运行时间。另外，在on_before_market_open中只有在撮合周期为日K时才能进行挂单。 on_bar(api, bar)-Bar响应回调 函数示例： def on_bar(api, bar): ... 说明： 创建实例时设置撮合周期，Bar产生时会调用。为了提高效率，只有在关注列表（即api.context.focus中存在的标的列表）中和有持仓的标的才会响应行情回调。当api.context.init.mode为'single_only' 或者 'both'时响应 on_handle_data(api, timestamp)-数据到齐后触发 函数示例： def on_handle_data(api, timestamp): print (api.context.time.now['%Y-%m-%d %H:%M:%S']) print (api.context.bar.focus) 说明： 针对某一周期的bar数据或者tick数据，搜集齐后再统一响应回调，timestamp为当前周期的时间戳。当api.context.init.mode为'group_only' 或者 'both'时响应 on_terminate(api, result)-运行终止 函数示例： def on_terminate(api, result): api.save_object('xxx', api.props(result)) 说明： 运行终止时会调用一次, result返回值为回测结果。 on_timer(api)-定时器 函数示例： def on_timer(api): ... 说明： 每隔api.context.init.time_cycle毫秒会响应一次。 on_order_update(api, order)-订单状态更新回调 函数示例： def on_order_update(api, order): ... 说明： 订单状态更新时会响应一次，order为订单详情。 内置上下文参数-api.context 取当前策略上下文的方式 api.context 取指定策略名称的上下文的方式 api.context['test'] 初始化参数 api.context.init 说明： 该参数仅在on_initialize事件能够被修改，其他事件时均只读，无法修改。如在其他函数中修改，会抛出异常。 一次性初始化示例： api.context.init = { # symbols里设置单个股票或者其他有效的标的 # symbol_sets里设置标的集合，如此处的IF.PRD指的就是IF品种的所有标准合约，不包含IFZ0.CF和IFZ1.CF # 注：symbols和symbol_sets不能全部为空 'symbols': ['IFZ0.CF'], 'symbol_sets': ['IF.PRD'], # 必填：设置所需k线类型，interval可以选取1分钟，5分钟，15分钟，30分钟，60分钟，日k，Tick级别，count为提前缓存的数目 'prepared_bars': [ {'interval': api.bar_span, 'count': 100}, {'interval': ETimeSpan.MIN_5, 'count': 100} ], # 选填：设置撮合参数 interval为撮合周期，time_ranges为日内撮合时间段，将只在指定时间段以interval周期回调on_bar或on_handle_date 'match_param': { 'interval': api.bar_span, # 'time_ranges': [('12:00', '14:45'), ('10:10', '11:00')] }, # 选填：为group_only，则只响应onHandleData；为single_only，则只响应on_bar；为both，则两个回调同时响应 'mode': 'group_only', # 选填：设置手续费 'commission': 0.0002, # 选填：仅回测生效的项，不设置时以web页面上的设置为准 'backtest': { # 回测开始日期 'start_date': 20180101, # 回测结束日期 'end_date': 20180123, # 设置滑点,取值为整数,标的价格浮动最小单位值的整数倍 'slippage': 2, # 设置账户初始资金 'cash': { # 设置A股资金 'CS': 0, # 设置期货资金 'CF': 11000000 } }, # 选填：仅模拟盘/实盘生效的项 'realtime': { # 设置开盘前回调on_before_market_open响应事件时间，默认为web页面上设置的时间 'pre_market_time': '19:00', # 设置收盘前最后一次回调on_bar或onHandleData响应事件时间，默认为web页面上设置的时间 'closing_time': '14:55', # 设置group模式下的组播，等待多少ms则强制响应，默认为5000ms 'group_timeout': 10000, # 设置onTimer响应时间(ms), 为0则不响应onTimer，默认情况下不回调onTimer 'timer_cycle': 60000 } } 单参数初始化示例： 必要 设置缓存股票池 # 注：symbols和symbol_sets不能全部为空 # symbols里设置单个股票或者其他有效的标的 api.context.init.symbols = ['IFZ0.CF'] # symbol_sets里设置标的集合，如此处的IF.PRD指的就是IF品种的所有标准合约，不包含IFZ0.CF和IFZ1.CF api.context.init.symbol_sets = ['IF.PRD'] 设置缓存K线或tick # 必填：设置所需k线类型，interval可以选取1分钟，5分钟，15分钟，30分钟，60分钟，日k，Tick级别，count为提前缓存的数目 api.context.init.prepared_bars = [ {'interval': api.bar_span, 'count': 100}, {'interval': ETimeSpan.MIN_5, 'count': 100} ] web可配选填项 设置撮合参数 # 选填：设置撮合参数 interval为撮合周期，time_ranges为日内撮合时间段，将只在指定时间段以interval周期回调on_bar或on_handle_date api.context.init.match_param.interval = api.bar_span api.context.init.match_param.time_ranges = [('12:00', '14:45'), ('10:10', '11:00')] 设置K线或tick响应方式 # 选填：为group_only，则只响应onHandleData；为single_only，则只响应on_bar；为both，则两个回调同时响应 api.context.init.mode = 'group_only' 设置手续费 # 选填：设置手续费 api.context.init.commission = 0.0002 设置回测参数 # 选填：仅回测生效的项，不设置时以web页面上的设置为准 # 回测开始日期 api.context.init.backtest.start_date = 20180101 # 回测结束日期 api.context.init.backtest.end_date = 20180123 # 设置滑点,取值为整数,标的价格浮动最小单位值的整数倍 api.context.init.backtest.slippage = 2 # 设置账户初始资金 # 设置A股资金 api.context.init.backtest.cash['CS'] = 0 # 设置期货资金 api.context.init.backtest.cash['CF'] = 1000000 设置实盘/模拟盘参数 # 选填：仅模拟盘/实盘生效的项 # 设置开盘前回调on_before_market_open响应事件时间，默认为web页面上设置的时间 api.context.init.realtime.pre_market_time = '19:00' # 设置收盘前最后一次回调on_bar或onHandleData响应事件时间，默认为web页面上设置的时间 api.context.init.realtime.closing_time = '14:55' # 设置group模式下的组播，等待多少ms则强制响应，默认为5000ms api.context.init.realtime.group_timeout = '10000' # 设置onTimer响应时间(ms), 为0则不响应onTimer，默认情况下不回调onTimer api.context.init.realtime.timer_cycle = '60000' 时间处理参数 EtaTime 类型 说明： 可以处理etasdk产生的所有时间参数，如bar.tradeDate(20180101)，bar.timeStop(1548744180000)，time等转化为api时间格式 1. 当前时间 说明： 回测则为回测当前时间 api.context.time.trade_now # 获取当前的交易日，注：期货夜盘归为下一交易日 api.context.time.now # 获取当前时间 2. 取年月日时分秒等 api.context.time.now.day # 日 12 api.context.time.now.hour # 时 15 api.context.time.now.minute # 分 0 api.context.time.now.second # 秒 0 api.context.time.now.week # 第几周 2 api.context.time.now.weekday # 星期几 0-6代表星期一-星期天 api.context.time.now.date # 日期 20180101 api.context.time.now['%Y%m%d'] # 按照指定的格式输出 '20180112' 3. 转化普通时间 说明： 将普通的时间标识转化为EtaTime格式可以使用该格式的取年月日时分秒等的方法 # 将20180101转为EtaTime格式 time = api.context.time[20180101] # 将unix时间戳转为EtaTime格式 time = api.context.time[1548744180000] # 将time.time格式转为EtaTime格式 time = api.context.time[dtime] 股票池参数 api.context.pool 说明： 该参数可以设置或者获取股票池类数据 api.context.pool.all # 获取全部缓存的股票池，此参数只读 api.context.pool.focus # 获取关注的股票池，此参数仅可在on_before_market_open被设置 api.context.pool.position # 获取全部持仓中的股票池，此参数只读 k线类参数 api.context.bar 说明： 该参数仅在on_handle_data里生效，其他事件调用无效，返回值为DataFrame格式 api.context.bar.focus # 获取关注的标的，当前收齐的bar api.context.bar.position # 获取持仓的标的，当前收齐的bar api.context.bar['IFZ0.CF'] # 获取指定的标的当前的bar，注：只能针对有关注的标的代码 可采用类似 api.context.bar.focus['close']取得数据 账户信息 api.context.account 说明：数据返回格式为Account api.context.account['CF'] # 获取期货账户信息 api.context.account['CS'] # 获取A股账户信息 账户持仓信息 api.context.positions 说明：数据返回格式为OverallPosition api.context.positions # 获取所有持仓标的的列表 api.context.positions['IFZ0.CF'] # 获取指定持仓标的的列表 策略信息 api.context.strategy 说明：数据返回格式为StrategyPnL api.context.strategy api.context['test'].strategy 策略持仓 数据返回格式为SymbolPosition # 策略持仓信息，数据返回格式为 SymbolPosition的数组 api.context.strategy.positions api.context.strategy.positions.short 所有空方向持仓 api.context.strategy.positions.long 所有多方向持仓 api.context.strategy.positions['IFZ0.CF'] 所有IFZ0.CF的持仓 # 数据返回格式为 SymbolPosition api.context.strategy.positions['IFZ0.CF'].short IFZ0.CF多仓 api.context.strategy.positions['IFZ0.CF'].long IFZ0.CF空仓 只盘前支持的函数 set_focus_symbols(symbols)-设置关注的标的池 与内置参数api.context.pool.focus功能一致。只能在on_before_market_open函数中调用，且必须调用。只有在此函数中进行设置的标的和当前持仓的标的才会在on_bar、on_handle_data或者on_tick函数中进行行情响应。若不设置关注的且不在持仓的标的不会在此三个回调事件中响应，并且获取不到该标的当天的K线。 **注：set_focus_symbols 如果多次使用，则只会记录最后一条的设置；前面的设置将会被覆盖** 函数原型： set_focus_symbols(symbols) 函数示例： def on_before_market_open(api, trade_date): ... api.set_focus_symbols('000001.CS') ... 参数： 参数 类型 是否必填 说明 symbols str or list 是 标的或标的列表 交易函数 target_position(symbol, qty, price, side, tif, remark, price_list)-目标仓位数量下单 函数原型： target_position(symbol, qty, price=None, side=None, tif =ETimeInForce.NONE, remark=None, price_list=EPriceList.None) 参数： 参数 类型 是否必填 说明 symbol str 是 策略中的标的代码 qty int 是 交易量 price double 否 价格，默认不传参（表示以当时现价下单），若传参则表示以该委托价下限价单 side EPositionSide 否 多或者空，不填时默认为多仓，股票不能为short。详见 EPositionSide 。 tif ETimeInForce 否 下单属性说明，不填和填NONE时效果相同，详见ETimeInForce-订单委托属性 remark str 否 下单原因说明，填写后可以在web端展示 price_list EtaPriceList 否 报价列表，用于下限价单。若与price同时传参，则以price为准，详见EtaPriceList-报价列表 返回值： orderID 作为对此条下单操作的标识。 举例： 股票下单 # 以市价单买入100股000001 api.target_position (symbol=\"000001.CS\", qty=100) # 以11元限价单买入100股000001 api.target_position (symbol=\"000001.CS\", qty=100, price=11) # 以市价单卖出000001股票至持仓为0，remark里的描述会在web交易信息里体现 api.target_position (symbol=\"000001.CS\", qty=0, remark=\"卖出平仓\") # 以限价单卖一价买入000001股票至持仓为100股 api.target_position (symbol=\"000001.CS\", qty=100, price_list=EPriceList.ASK1) 期货下单 # IF1809市价单开多1手 api.target_position (symbol='IF1809.CF',qty=1, side=EPositionSide.LONG) # IF1809市价单开空1手 api.target_position (symbol='IF1809.CF',qty=1, side=EPositionSide.SHORT) 注意：以报价列表方式挂限价单不能在on_before_market_open中挂单 cancel_order(symbol, side)-撤单 函数原型 cancel_order(symbol， side=EPositionSide.LONG, remark='') 参数： 参数 类型 是否必填 说明 symbol str 是 策略中的标的代码 side EPositionSide 否 多或者空，不填时默认为多仓，股票不能为short。详见 EPositionSide 。 remark str 否 撤单原因说明，填写后可以在web端展示 举例： #撤销股票000001.CS的挂单 api.cancel_order(symbol=\"000001.CS\", remark=\"撤销000001.CS的挂单\") #撤销期货rb1901.CF的空头挂单 api.cancel_order(symbol=\"rb1901.CF\", side=EPositionSide.SHORT) 查询函数 获取策略/账户信息 get_symbol_position(symbol, side) 获取策略级别单个标的仓位 函数原型： get_symbol_position(symbol, side=None) 参数： 参数 类型 是否必填 说明 symbol str 是 标的代码 side EPositionSide 否 多或者空，不填时默认为多仓，股票不能为short。详见EPositionSide 。 返回值：SymbolPosition对象。 举例： #获取股票000001.CS仓位信息 symbolposition = api.get_symbol_position (symbol=\"000001.CS\") #获取期货IF1809.CF多仓的仓位信息 symbolposition = api.get_symbol_position (symbol=\"IF1809.CF\", side=EPositionSide.LONG) #获取期货IF1809.CF空仓的仓位信息 symbolposition = api.get_symbol_position (symbol=\"IF1809.CF\"，side=EPositionSide.SHORT) get_symbol_positions() 获取所有持仓标的仓位信息 函数原型： get_symbol_positions() 参数：无 返回值：list结构，元素为SymbolPosition对象。 举例： #获取所有标的的仓位信息 symbolpositions = api.get_symbol_positions() get_account(symbol, market) 获取标的或者市场所属账户信息 获取标的所属账号信息，由于账号获取是异步的，所以下完单立即获取账户数据会有延迟。 函数原型： get_account(symbol=None, market=None) 参数： 参数 类型 是否必填 说明 symbol str 否 标的代码，可缺省，但不能同时和市场一起缺省，若都不缺省以market为准 market str 否 市场，主要有股票MARKET_CHINASTOCK和期货MARKET_CHINAFUTURE 返回值：标的所属证券的市场账号信息，Account结构。 举例： # 用标的获取A股账号的信息 account = api.get_account(symbol='000001.CS') # 用市场获取A股账号的信息 account = api.get_account(market=MARKET_CHINASTOCK) # 同时填入标的和市场时，返回通过市场获取的账号信息，如下返回期货账号信息 account = api.get_account(symbol='000001.CS', market=MARKET_CHINAFUTURE) get_overall_position(symbol) 获取标的汇总仓位 由于多个策略可以共享账户资金，因此可能会存在多个策略中都持有某个标的的情况，账户中会将多个策略中标的信息进行汇总。本函数用来获取某个标的在账户中汇总后的仓位信息。 函数原型： get_overall_position(symbol) 参数： 参数 类型 是否必填 说明 symbol str 是 标的代码 返回值：该标的在其所属账户中的总仓位信息，OverallPosition对象结构。 举例： #获取账户下000001.CS的汇总仓位信息 overallposition = api.get_overall_position(symbol=\"000001.CS\") # 获取000001.CS仓位信息 availableqty = overallposition.longAvailableQty # 获取多仓可平仓数量 get_strategy_PnL-获取策略盈亏信息 函数原型： get_strategy_PnL() 参数：无 返回值：策略盈亏信息，StrategyPnL对象结构 举例： strategyPnL= api.get_strategy_PnL() #获取策略盈亏信息 overallPnL = strategyPnL.overallPnL #获取策略总盈亏字段数据 获取交易日期 get_trade_day_interval(symbol, start_date, end_date) 获取交易日数 获取某时间区间交易日数，起止时间只能是回测区间内的 函数原型： get_trade_day_interval(symbol, start_date, end_date) 参数： 参数 类型 是否必填 说明 symbol str 是 标的代码 start_date int 是 开始时间，格式为YYMMDD end_date int 是 结束时间，格式为YYMMDD 返回值：返回值为交易日数 举例： 获取一段时间内的交易日数，包含所传起止日期 data = api.get_trade_day_interval(symbol=\"000002.CS\", start_date=20151217, end_date=20160704) 返回结果： 3 # 过滤停牌日期 get_prev_trade_date(trade_date, market) 获取上一个交易日期 获取上一个交易日期 函数原型： get_prev_trade_date(trade_date，market=None) 参数： 参数 类型 是否必填 说明 tradeDate int 是 交易日，格式为YYMMDD market str 否 市场代码，不填默认返回A股市场的交易日 返回值：返回上一交易日的日期 举例： api.get_prev_trade_date(trade_date=20150101) # 返回值为20141231 api.get_prev_trade_date(trade_date=20150101, market=\"CS\") # 返回值为20141231 get_next_trade_date(trade_date, market) 获取下一个交易日期 获取下一个交易日期 函数原型： get_next_trade_date(trade_date，market=none) 参数： 参数 类型 是否必填 说明 trade_date int 是 开始时间，格式为YYMMDD market str 否 市场代码，不填默认返回A股市场的交易日 返回值：返回下一交易日的日期 举例： api.get_next_trade_date(trade_date=20150101) # 返回值为20150105 api.get_next_trade_date(trade_date=20150101, market='CS') # 返回值为20150105 get_trade_dates(start_date, end_date, market, period) 获取一段时间内交易日期 指定起止日期，获取某个市场一段时间的交易日期 函数原型： get_trade_dates(start_date, end_date, market=None，period=('D', 1)) 参数： 参数 类型 是否必填 说明 start_date int 是 开始时间（含当天），格式为YYMMDD end_date int 是 结束时间（含当天），格式为YYMMDD market str 否 交易市场,不填默认返回A股市场的交易日 period tuple 否 变频参数，D-每天一值、W-每周一值、M-每月一值、Q-每季度一值、S-每半年一值、Y-每年一值;1-第一个交易日，-1-最后一个交易日;不填默认返回全部即(D,1) 返回值：交易日list，日期格式YYYMMDD，类型为int 举例： 获取一段时间内的交易日期，包含所传起止日期 api.get_trade_dates(start_date=20171001, end_date =20171011) 返回结果： [20171009, 20171010, 20171011] get_prev_trade_dates(trade_date, count, market, period) 获取某个市场截止指定日期的多个交易日期 指定截止日期，返回某个市场指定天数的交易日期 函数原型： get_prev_trade_dates(trade_date, count, market=None，period=('D', 1)) 参数： 参数 类型 是否必填 说明 tradeDate date 是 截止日期（含当天），格式为YYMMDD count int 是 返回天数（含当天），count需大于0 mktIndex str or list 否 交易市场,不填默认返回A股市场的交易日 period tuple 否 变频参数，D-每天一值、W-每周一值、M-每月一值、Q-每季度一值、S-每半年一值、Y-每年一值;1-第一个交易日，-1-最后一个交易日;不填默认返回全部即(D,1) 返回值：交易日list，日期格式YYYMMDD，类型为int 举例： api.get_prev_trade_dates(20181008,7) # 返回A股市场截止20181008日7个交易日日期 返回结果 [20180920, 20180921, 20180925, 20180926, 20180927, 20180928, 20181008] date_now() 获取当前交易日期 获取当前的交易日期。回测情况下是回测历史当天，交易情况下是当前交易日。 函数原型： date_now() 参数： 无 返回值：返回历史当天的交易日期，期货夜盘默认归为后一交易日, api.context.time类型 time_now() 获取当前交易时间 获取当前的交易时间。回测情况下是回测历史当天，交易情况下是当前交易日。 函数原型： time_now() 参数： 无 返回值：返回历史当前的时间, api.context.time类型 获取标的信息 get_ref_data(symbol) 获取标的基本信息 函数原型： get_ref_data(symbol) 参数： 参数 类型 是否必填 说明 symbol str 是 标的代码 返回值：证券基本信息，RefData。 举例： # 获取000001.CS证券基本信息 ref_data = api.get_ref_data(symbol=\"000001.CS\") get_constituent_symbols(symbol_set, trade_date) 获取成分股数据 函数原型： get_constituent_symbols(symbol_set, trade_date=None) 获取股票指数或者行业板块的成分股数据。获取期货某品种当前可交易的标的数据。详见指数代码说明。 参数： 参数 类型 是否必填 说明 symbol_set str or list 是 指数代码、板块代码、指数代码列表或者行业板块代码列表，为列表时表示获取的股票同时属于这些指数或者行业。 trade_date int 否 交易日，形式为YYYYMMDD，支持获取历史成分股信息，不填默认返回当天的数据 返回： 返回股票代码的list 举例： 获取上证指数成分股 symbols = api.get_constituent_symbols(symbol_set=\"000001.IDX\", trade_date=20170403) 返回结果： ['600023.CS', '600908.CS', '600909.CS', '600917.CS', '600919.CS', '600926.CS', '600936.CS', '600939.CS', '600958.CS', '600959.CS', '600977.CS', '600996.CS', '600998.CS', '600999.CS', '601000.CS', '601002.CS', '601003.CS', '601005.CS', '601007.CS', '601008.CS', '601009.CS', '601010.CS', '601011.CS', '601012.CS', '601015.CS', '601016.CS', '601018.CS', '601020.CS', '601021.CS', '601028.CS', '601038.CS', '601058.CS', '601069.CS', '601088.CS', '601098.CS', '601099.CS', '601100.CS', '601101.CS', '601106.CS', ...] 获取RU的可以交易标的列表 ru_now = api.get_constituent_symbols(symbol_set=\"ru.PRD\", trade_date=20170403) 返回结果： ['ru1704.CF', 'ru1705.CF', 'ru1706.CF', 'ru1707.CF', 'ru1708.CF', 'ru1709.CF', 'ru1710.CF', 'ru1711.CF', 'ru1801.CF', 'ru1803.CF'] 获取优品行业板块集合的列表 up_now = api.get_constituent_symbols(symbol_set=\"UPPLA.SET\", trade_date=20170403) 返回结果： ['880001.PLA', '880002.PLA', '880003.PLA', '880004.PLA', '880007.PLA', '880008.PLA', '880009.PLA', '880010.PLA', '880012.PLA', '880013.PLA', '880014.PLA', '880015.PLA', '880016.PLA', '880017.PLA', '880018.PLA', '880019.PLA', '880020.PLA', '880021.PLA', '880022.PLA', '880023.PLA', '880024.PLA', '880025.PLA', '880026.PLA', '880027.PLA', '880028.PLA', '880029.PLA', '880030.PLA', '880031.PLA', '880033.PLA', '880035.PLA', '880039.PLA', '880041.PLA', '880042.PLA', '880043.PLA', '880044.PLA', '880045.PLA', '880046.PLA', '880047.PLA', '880048.PLA', '880049.PLA', '880050.PLA', '880051.PLA', '880052.PLA', '880053.PLA', '880056.PLA', '880057.PLA', '880058.PLA', '880059.PLA', '880060.PLA', '880064.PLA', '880065.PLA'] get_continuous_symbol(symbol, trade_date) 获取连续合约对应的标的 函数原型： get_continuous_symbol(symbol, trade_date=None) 传入连续合约代码，获取对应的实际的标的代码。期货专用。 参数： 参数 类型 是否必填 说明 symbol str 是 连续合约的代码，包括主力、次主力合约，当月、次月、下季、隔季连续合约 trade_date int 否 指定某个交易日，不填则默认为回测当天。形式为YYYYMMDD 返回：连续合约对应的期货代码。 举例： 获取主力合约在某交易日对应的标准合约 api.get_continuous_symbol(symbol=\"jmZ0.CF\", trade_date=20180820) 返回结果： jm1901.CF get_appointed_symbols(mode, trade_date) 获取指定合约集合 获取指定合约集合，如主力合约集合，次主力合约集合。 函数原型： get_appointed_symbols(mode, trade_date=None) 参数： 参数 类型 是否必填 说明 mode str 是 指定合约的类型，有Z0、Z1，Y1-Y12 trade_date int 否 交易日 ，形式为YYYYMMDD，不填默认返回当天的数据 返回： 返回指定合约集合 举例： 获取20180710当天的所有主力合约 api.get_appointed_symbols(mode='Z0', trade_date=20180710) 返回结果 ['APZ0.CF', 'CFZ0.CF', 'CYZ0.CF', 'FGZ0.CF', 'ICZ0.CF', 'IFZ0.CF', 'IHZ0.CF', 'JRZ0.CF', 'LRZ0.CF', 'MAZ0.CF', 'OIZ0.CF', 'PMZ0.CF', 'RIZ0.CF', 'RMZ0.CF', 'RSZ0.CF', 'SFZ0.CF', 'SMZ0.CF', 'SRZ0.CF', 'TAZ0.CF', 'TFZ0.CF', 'TZ0.CF', 'WHZ0.CF', 'ZCZ0.CF', 'aZ0.CF', 'agZ0.CF', 'alZ0.CF', 'auZ0.CF', 'bZ0.CF', 'bbZ0.CF', 'buZ0.CF', 'cZ0.CF', 'csZ0.CF', 'cuZ0.CF', 'fbZ0.CF', 'fuZ0.CF', 'hcZ0.CF', 'iZ0.CF', 'jZ0.CF', 'jdZ0.CF', 'jmZ0.CF', 'lZ0.CF', 'mZ0.CF', 'niZ0.CF', 'pZ0.CF', 'pbZ0.CF', 'ppZ0.CF', 'rbZ0.CF', 'ruZ0.CF', 'scZ0.CF', 'snZ0.CF', 'vZ0.CF', 'wrZ0.CF', 'yZ0.CF', 'znZ0.CF'] 获取当天（20181127）所在月份为1的所有合约，若某标的同时存在1901和2001则返回较近的合约，即1901 api.get_appointed_symbols(mode=\"Y1\") 返回结果 ['OI1901.CF', 'ZC1901.CF', 'cu1901.CF', 'y1901.CF', 'WH1901.CF', 'bb1901.CF', 'FG1901.CF', 'rb1901.CF', 'sc1901.CF', 'sn1901.CF', 'RI1901.CF', 'm1901.CF', 'CY1901.CF', 'SR1901.CF', 'al1901.CF', 'a1901.CF', 'c1901.CF', 'JR1901.CF', 'fb1901.CF', 'i1901.CF', 'l1901.CF', 'RM1901.CF', 'IH1901.CF', 'ag1901.CF', 'IC1901.CF', 'IF1901.CF', 'au1901.CF', 'ru1901.CF', 'zn1901.CF', 'pp1901.CF', 'p1901.CF', 'j1901.CF', 'jd1901.CF', 'TA1901.CF', 'MA1901.CF', 'ni1901.CF', 'bu1901.CF', 'pb1901.CF', 'hc1901.CF', 'wr1901.CF', 'jm1901.CF', 'cs1901.CF', 'v1901.CF', 'b1901.CF', 'SF1901.CF', 'LR1901.CF', 'SM1901.CF', 'PM1901.CF', 'CF1901.CF', 'AP1901.CF', 'fu1901.CF'] is_suspend(symbol, trade_date) 是否停牌 判断标的当日是否停止交易 函数原型： is_suspend(symbol, trade_date=None) 参数： 参数 类型 是否必填 说明 symbol str 是 策略中的证券代码 trade_date int 否 交易日，形式为YYYYMMDD，可以查询历史上的状态，不填默认返回当天的数据 返回值：返回True表示停牌，返回False表示未停牌 举例： api.is_suspend(symbol=\"000001.CS\",trade_date=20180104) # 获取000001.CS在20180104是否停牌 is_ST(symbol, trade_date) 是否ST股 判断标的当日是否ST股 函数原型： is_ST(symbol, trade_date=None) 参数： 参数 类型 是否必填 说明 symbol str 是 策略中的证券代码 trade_date int 否 交易日，形式为YYYYMMDD，可以查询历史上的状态，不填默认返回当天的数据 返回值：返回True表示ST股，返回False表示非ST股 举例： api.is_ST(symbol =\"000001.CS\",trade_date =20180104)#获取000001.CS在20180104是否ST is_listed(symbol, trade_date) 是否上市 判断标的当日是否上市 函数原型： is_listed(symbol, trade_date=None) 参数： 参数 类型 是否必填 说明 symbol str 是 策略中的证券代码 trade_date int 否 交易日，形式为YYYYMMDD，可以查询历史上的状态，不填默认返回当天的数据 返回值：返回True表示上市，返回False表示未上市或者已退市 举例： api.is_listed(symbol=\"000001.CS\",trade_date=20180104) # 获取000001.CS在20180104是否上市 获取标的数据 get_bars_history(symbol, time_span, count, price_mode, skip_suspended, fields) 获取历史K线数据 获取K线数据。模拟盘和实盘在on_handle_data 和 on_bar中获取当天的日K不是全日K线，是开盘时间到所设置的收盘时间的日K。 注意： 调用此api之前需在初始化initialize中设置所需的symbols和prepared_bars，否则可能取不到字段值。 函数原型： get_bars_history(symbol, time_span, count=None，price_mode=EPriceMode.REAL, skip_suspended=True, fields=None) 参数： 参数 类型 是否必填 说明 symbol str 是 标的代码 time_span ETimeSpan 是 bar的频率，详见 ETimeSpan。 count int 是 获取历史数据条数，超过缓存类型的返回空 price_mode EPriceMode 否 复权模式，不填默认返回不复权，详见EPriceMode 。 skip_suspended bool 否 为了保证取不同标的数据时时间对齐，可以设置是否跳过停牌， 不填写默认为跳过。若不跳过，填充方式为高开低收均用前收盘价填充，成交量=成交额=0。 fields str or list 否 返回的字段，不填默认返回全部。 返回值：行情数据 ,默认返回dataFrame格式。 举例： 获取不过滤停牌的前复权5分钟K线2支 # 然后在对应事件回调中获取历史K线 bars = api.get_bars_history(symbol =\"000001.CS\", time_span=ETimeSpan.MIN_5, count=2, price_mode=EPriceMode.FORMER, skip_suspended=0) 返回结果： [{ \"symbol\": \"000001.CS\", \"timeSpan\": 300, \"timeStop\": 1543215300000, \"timeStr\": \"20181126-145500-000\", \"tradeDate\": 20181126, \"close\": 10.32, \"high\": 10.33, \"isSuspended\": False, \"low\": 10.31, \"open\": 10.32, \"position\": 0, \"preClose\": 10.32, \"preSettle\": 0, \"settle\": 0, \"totalTurnover\": 5.24417e+08, \"totalVolume\": 5.05396e+07, \"turnover\": 1.37453e+07, \"volume\": 1.33236e+06 }, { \"symbol\": \"000001.CS\", \"timeSpan\": 300, \"timeStop\": 1543215600000, \"timeStr\": \"20181126-150000-000\", \"tradeDate\": 20181126, \"close\": 10.34, \"high\": 10.34, \"isSuspended\": False, \"low\": 10.32, \"open\": 10.32, \"position\": 0, \"preClose\": 10.32, \"preSettle\": 0, \"settle\": 0, \"totalTurnover\": 5.35963e+08, \"totalVolume\": 5.16569e+07, \"turnover\": 1.15462e+07, \"volume\": 1.1173e+06 }] 某个字段值： bars[0].totalTurnover # 交易日总成交额 返回结果： 524417138.0 获取不过滤停牌的不复权5分钟K线2支，格式为DataFrame bars = api.get_bars_history(symbol='000001.CS', time_span=ETimeSpan.MIN_5, count=2) 返回结果： timeStr timeStop symbol tradeDate close high low open preClose settle preSettle volume turnover totalVolume totalTurnover position isSuspended 0 20181126-145500-000 1543215300000 000001.CS 20181126 10.32 10.33 10.31 10.32 10.32 0.0 0.0 1332361.0 13745256.0 50539573.0 524417138.0 0.0 False 1 20181126-150000-000 1543215600000 000001.CS 20181126 10.34 10.34 10.32 10.32 10.32 0.0 0.0 1117298.0 11546172.0 51656871.0 535963310.0 0.0 False 获取不过滤停牌的不复权5分钟K线2支，格式为DataFrame，返回列为tradeDate和close，该返回值必然会 bars = api.get_bars_history(symbol='000001.CS',timeSpan=ETimeSpan.MIN_5, count=2, fields=['tradeDate', 'close']) 返回结果： tradeDate close 0 20181126 10.32 1 20181126 10.34 get_value_field(symbols, fields, start_date, end_date, count) 获取数值类因子 获取数值类因子数据。数据信息详见股票交易指标-日频。 调用此api之前需在初始化initialize中设置缓存的symbol和field，否则可能取不到字段值 函数原型 get_value_field(symbols, fields=None, start_date=None, end_date=None, count=None) 参数： 参数 类型 是否必填 说明 symbols str or list 是 股票或者股票列表 fields str or list 是 选取的股票属性，可以选择多个 start_date int 否 指定某个交易日，不填则默认其他方式返回 end_date int 否 指定某个交易日，不填则默认为回测上一交易日。形式为YYYYMMDD count int 否 指定从end_date往前count个交易日的时间段 返回：返回DataFrame格式 举例： 获取多只标的在某交易日的因子数据 data = api.get_value_field(symbols=[\"000002.CS\", \"600000.CS\"], fields=[\"PE\", \"TRADE_STA\"], start_date=20181122) 返回结果： PE TRADE_STA symbol tradeDate 0 5.6400 True 000002.CS 20181122 1 5.5501 True 600000.CS 20181122 获取某标的在一段时间内的因子数据 data = api.get_value_field(symbols=\"000001.CS\", fields=[\"PE\",\"REVENUE\",\"TRADE_STA\", \"TOT_SHARE\", \"LIST_STA\"], start_date=20181116, end_date=20181120) 返回结果： LIST_STA PE REVENUE TOT_SHARE TRADE_STA symbol tradeDate 0 1 7.4102 8.666400e+10 1.717041e+10 True 000001.CS 20181116 1 1 7.6065 8.666400e+10 1.717041e+10 True 000001.CS 20181119 2 1 7.4102 8.666400e+10 1.717041e+10 True 000001.CS 20181120 获取字段值 data.ix[0:1,[\"REVENUE\",\"PE\"]] #获取前两行的\"REVENUE\",\"PE\"字段值 返回结果： REVENUE PE 0 8.666400e+10 7.4102 1 8.666400e+10 7.6065 获取基于某交易日往前推的两条数据，格式为dataFrame datas = api.get_value_field(symbols=\"000001.CS\", fields=[\"TOT_SHARE\", \"BASIC_EPS\", \"PE\"], start_date=20181122, count=2) 返回结果： BASIC_EPS PE TOT_SHARE symbol tradeDate 0 1.14 7.4383 1.717041e+10 000001.CS 20181121 1 1.14 7.3962 1.717041e+10 000001.CS 20181122 get_finance_fields(symbols, fields, trade_date, report) 获取财务数据(单交易日) 获取股票的财务数据。数据信息详见股票财务数据（季频）)。 调用此api之前需在初始化initialize中设置相关股票池和所需因子，否则可能取不到字段值 函数原型 get_finance_field(symbols, fields=None, trade_date=None, report=None) 参数： 参数 类型 是否必填 说明 symbols str 是 股票代码或列表 fields str or list 是 选取的股票属性，可以选择多个 trade_date int 否 交易日，形式为YYYYMMDD，为了避免未来函数只能获取到所传交易日之前的数据，不填默认返回上一交易日 report str 否 指定报告期，例如'2016Q1' - 16年一季报，'2016Q2' - 16年半年报，'2016Q3' - 16年三季报，'2016Q4'-年报，report缺省时返回标的最新的报告期数据。 返回：返回DataFrame格式 举例： 获取000001.CS的2016年年报数据，当前交易日为20181126 data = api.get_finance_field(symbols=\"000001.CS\", fields=[\"REVENUE\", \"NET_PROFIT\", \"NET_PROFIT_ATTRP\"], trade_date=20170505, report=\"2016Q4\") 返回结果： NET_PROFIT NET_PROFIT_ATTRP REVENUE reportdate symbol tradeDate 0 2.259900e+10 2.259900e+10 1.077150e+11 20161231 000001.CS 20170505 get_table_field(symbol, field, start_date, end_date, count, columns) 获取表格类因子数据 表格类因子数据，数据信息详见表格型数据 由于表格类数据的数据量相对较大，因此只提供单标的单因子的数据取用接口 函数原型： get_table_field(symbol, field, start_date=None, end_date=None, count=None, columns=[]) 参数： 参数 类型 是否必填 说明 symbol str 是 股票代码 field str 是 因子名 ，详见平台数据 start_date int 否 指定某个交易日，不填则默认为回测上一交易日。形式为YYYYMMDD end_date int 否 指定起始交易日 count int 是 获取基于所传交易日往前推的N条数据（包含所传交易日当天） columns list 否 返回的字段；为空时,默认返回所有列,否则返回指定的列 返回：返回DataFrame格式 举例： 获取a1901.CF上一交易日成交量排名列表 api.get_table_field(symbol='a1901.CF', field='FUT_TRADE_RANK', start_date=20181120, columns=['rank', 'name', 'volume', 'volumeDiff']) 返回结果： name rank tradeDate volume volumeDiff 0 东证期货 1 20181120 14924.0 6320.0 1 中信期货 2 20181120 14329.0 5721.0 2 海通期货 3 20181120 7742.0 1050.0 3 国泰君安 4 20181120 7029.0 1654.0 4 华泰期货 5 20181120 6147.0 2323.0 5 华安期货 6 20181120 5279.0 -899.0 ... 14 中信建投 15 20181120 3096.0 1776.0 15 银河期货 16 20181120 3059.0 543.0 16 广发期货 17 20181120 2804.0 438.0 17 南华期货 18 20181120 2392.0 -231.0 18 渤海期货 19 20181120 2318.0 1766.0 19 上海大陆 20 20181120 2245.0 1813.0 获取申万一级行业板块的K线数据 api.get_table_field('801780.PLA', 'SW_MKT', 20181122) 返回结果： close high low open preClose totalTurnover totalVolume tradeDate 0 3302.34 3320.06 3291.49 3320.06 3314.79 752355335.0 5.570303e+09 20181122 获取a1901.CF多个交易日的成交量排名列表 api.get_table_field(symbol='a1901.CF', field='FUT_TRADE_RANK', start_date=20181122, end_date=20181124, columns=['rank', 'name', 'volume', 'volumeDiff']) 返回结果为： name rank tradeDate volume volumeDiff 0 东证期货 1 20181122 8705.0 -4422.0 1 中信期货 2 20181122 7001.0 -6352.0 2 国泰君安 3 20181122 5417.0 -1273.0 3 海通期货 4 20181122 4833.0 -3542.0 4 方正中期 5 20181122 4043.0 -619.0 5 华泰期货 6 20181122 3838.0 -2074.0 6 国信期货 7 20181122 3259.0 -308.0 7 徽商期货 8 20181122 3174.0 173.0 8 渤海期货 9 20181122 3116.0 1557.0 9 兴证期货 10 20181122 2990.0 -2049.0 ... 31 国投安信 12 20181123 4174.0 2147.0 32 中信建投 13 20181123 3563.0 738.0 33 大有期货 14 20181123 3199.0 1939.0 34 渤海期货 15 20181123 3125.0 9.0 35 永安期货 16 20181123 2979.0 453.0 36 银河期货 17 20181123 2870.0 1230.0 37 宏源期货 18 20181123 2575.0 1276.0 38 东航期货 19 20181123 2250.0 663.0 39 广发期货 20 20181123 2040.0 729.0 获取申万一级行业板块多个交易日的K线数据 api.get_table_field('801010.PLA', \"SW_MKT\", start_date=20181122, end_date=20181123) 返回结果为： close high low open preClose totalTurnover totalVolume tradeDate 0 2272.95 2293.86 2264.67 2289.74 2286.45 8.149344e+08 5.235480e+09 20181122 1 2230.37 2276.36 2222.91 2276.36 2272.95 1.033341e+09 6.586772e+09 20181123 获取a1901.CF多个交易日成交量排名列表 api.get_table_field(symbol='a1901.CF', field='FUT_TRADE_RANK', start_date=20181122, count=2, columns=['rank', 'name', 'volume', 'volumeDiff']) 返回结果为： name rank tradeDate volume volumeDiff 0 中信期货 1 20181121 13353.0 -976.0 1 东证期货 2 20181121 13127.0 -1797.0 2 海通期货 3 20181121 8375.0 633.0 3 国泰君安 4 20181121 6690.0 -339.0 4 华泰期货 5 20181121 5912.0 -235.0 5 兴证期货 6 20181121 5039.0 138.0 6 方正中期 7 20181121 4662.0 659.0 7 国信期货 8 20181121 3567.0 -131.0 8 国投安信 9 20181121 3531.0 -988.0 9 华安期货 10 20181121 3369.0 -1910.0 10 光大期货 11 20181121 3269.0 -502.0 11 徽商期货 12 20181121 3001.0 -1614.0 ... 30 华安期货 11 20181122 2890.0 -479.0 31 中信建投 12 20181122 2825.0 512.0 32 永安期货 13 20181122 2526.0 339.0 33 光大期货 14 20181122 2249.0 -1020.0 34 国投安信 15 20181122 2027.0 -1504.0 35 南华期货 16 20181122 2024.0 183.0 36 银河期货 17 20181122 1640.0 -1070.0 37 东航期货 18 20181122 1587.0 -132.0 38 浙商期货 19 20181122 1570.0 273.0 39 安粮期货 20 20181122 1386.0 -171.0 获取申万一级行业板块多个交易日的K线数据 api.get_table_field(symbol='801010.PLA', field=\"SW_MKT\", start_date=20181122, count=3) 返回结果如下： close high low open preClose totalTurnover totalVolume tradeDate 0 2263.10 2312.21 2261.69 2307.56 2320.63 1.143088e+09 7.398032e+09 20181120 1 2286.45 2288.83 2240.66 2251.17 2263.10 1.015610e+09 6.188521e+09 20181121 2 2272.95 2293.86 2264.67 2289.74 2286.45 8.149344e+08 5.235480e+09 20181122 更多 get_dynamic_value(field) 获取动态运行参数 在web页面上创建策略时可以预先设置动态参数，在策略中可以通过此接口获取到该策略的动态参数信息。页面上对参数的改动可以立即反映在策略中。 函数原型： get_dynamic_value(field) 参数： 参数 类型 是否必填 说明 field str 是 参数名称 返回值： 参数值。根据预设的参数类型返回值类型。 举例： high=api.get_dynamic_value('high') # 在页面配置了名称为high的参数，获取当前策略high参数 get_define_data-获取命令行参数 函数原型： get_define_data(name, default_value, dtype) 参数： 参数 类型 是否必填 说明 name str 是 命令行传入的名称 default_value dtype 否 默认值为空，类型和dtype一致 dtype type 是 类型，有str、int等 举例： 在命令行输入如下命令 python main.py --name=upchina --value=20，在策略里可以通过api.get_define_data()获取，形式如下： api.get_define_data(name='name', default_value='myname', dtype=str) api.get_define_data(name='value', default_value=0, dtype=int) 上一个结果会获取到'upchina' 下一个结果获取到20 示例： 为了能动态的调整策略参数，可以通过命令行传入参数值，举例如下： 新建策略文件example.py，通过N条历史K线的收盘价的平均值和当前收盘价作比较进行下单，运行结束后调用on_terminate事件，将结果存储于result.txt文件中，代码如下： from etasdk import * import time def on_initialize(api): print(\"on_initialize\") #获取命令行参数 api.bar_len = api.get_define_data('bar_len', 10, int) ... def on_before_market_open(api, data): print(\"time----\",data) api.context.pool.focus = [...] def on_bar(api, bar): ... def on_terminate(api, exit_info): #存储结果 api.save_object('result-{}-{}.obj'.format(api.bar_len, int(time.time())), api.props(exit_info)) 创建一个用于批处理的文件batch.py，代码如下： #!/usr/bin/env python # -*- coding: utf-8 -*- import subprocess # 调参, 来优化策略的参数 n_bar_lenth = [i for i in range(10, 20, 2)] for l in n_bar_lenth: args = ' --bar_len=' + str(l) print args status = subprocess.call(\"python strategy.py\" + args, shell=True) #运行会循环bar_len, 动态调整参数, 调用策略, 并在策略中保存最后的结果 通过运行batch.py文件，会循环调用main.py，K线条数分别是10、12、14、16、18，循环运行五次结果会存储在result-x-xxxxxx.obj文件中，通过对比几次运行结果的数据，来选择最优的参数，以上举例仅供参考。 log.*-日志输出 函数原型： log.debug(msg) #DEBUG级别日志 log.info(msg) #INFO级别日志 log.error(msg) #ERROR级别日志 参数： 参数 类型 说明 msg str 日志内容 返回值：日志打印的内容 举例： 日志打印的级别与config配置中的\"loglevel\"级别一一对应，即loglevel为info就调用log.info，loglevel为error就调用log.error输出日志。 log.info(\"current tradedate {}, last tradedate {}\".format(curr,prev)) # 打印当前交易日和上一交易日 log.info(\"current tradedate = {} \".format(curr)) # 打印当前交易日 策略打印日志注意事项： 1、尽量不要输出中文，不同的python环境，输出中文后，有可能出现莫名其妙的问题 2、选股、下单等依据数据的关键数据点，要用 log.info 输出日志，这样模拟盘会把日志输出到algo.python_main.log 这个文件里，回测的时候不会输出，因为回测日志级别默认是error，如果回测也想打印日志可以用log.error或者将config中的日志级别改成info（后者会影响回测速度）； 3、更重要的数据，可以调用 api.send_custom_msg 把日志信息输出到web平台上，但是这个接口不要调用太多，有性能问题 send_custom_message(msg) 设置用户自定义运行消息 设置用户自定义运行消息，会显示在界面上的日志中 函数原型： sendCustomMsg(msg) 参数： 参数 类型 说明 msg str 内容 返回值：无 "},"starategy6.html":{"url":"starategy6.html","title":"策略示例","keywords":"","body":"策略示例 入门策略 buySellSymbol-股票买卖策略 #!/usr/bin/env python # -*- coding: utf-8 -*- from etasdk import * ''' 股票策略：买卖策略 本策略是一个简单的买卖策略，主要是体现如何下单的。当没有持仓时就进行买入操作，当有持仓时，就进行卖出平仓操作 回测标的：平安银行（000001.CS） 回测周期：20180702-20181101 撮合周期：日K 更多详情请看帮助文档：http://quant.upchina.com/doc/first.html ''' if __name__ == '__main__': # 读取配置文件并启动策略 config = { \"host\": \"120.55.22.60\", \"port\": 80, \"user\": \"SDK-User\", # Web端：点击量化平台右上角用户名可查看填写 \"token\": \"SDK-Token\", # Web端：点击量化平台右上角用户名可查看填写 \"strategy_name\": \"buySellSymbol\", # Web端：策略名称 \"console\": 0, \"loglevel\": \"ERROR\", # 显示日志级别，具体可查看帮助文档 \"instance_id\": \"20190222-113322-609-001BI\", # Web端：回测记录中本策略的回测ID,点击复制ID,粘贴此处即可 # 初始化参数 \"initialize\": { # symbols里设置单个股票或者其他有效的标的 # symbol_sets里设置标的集合，如此处的IF.PRD指的就是IF品种的所有标准合约，不包含IFZ0.CF和IFZ1.CF # 注：symbols和symbol_sets不能全部为空 'symbols': ['000001.CS'], # fields缓存的因子 # 'fields': ['FUT_TRADE_RANK', 'FUT_SHORT_RANK', 'FUT_LONG_RANK', 'STK_HOLD_DET', 'STK_HOLD_STAT', 'ST_STA','LIST_STA', 'TRADE_STA', 'NET_PROFIT', 'PB', 'PE', 'PS', 'PE_TTM'], # 必填：设置所需k线类型，interval可以选取1分钟，5分钟，15分钟，30分钟，60分钟，日k，Tick级别，count为提前缓存的数目 'prepared_bars': [{'interval': ETimeSpan.DAY_1, 'count': 60}], # 选填：设置撮合参数 interval为撮合周期，time_ranges为日内撮合时间段，将只在指定时间段以interval周期回调on_bar或on_handle_date 'match_param': { 'interval': ETimeSpan.DAY_1, # 'time_ranges': [('12:00', '14:45'), ('10:10', '11:00')] }, 'mode': 'both', # 选填：为group_only，则只响应on_handle_data；为single_only，则只响应on_bar；为both，则两个回调同时响应 'commission': 0.0002, # 选填：设置手续费 # 选填：仅回测生效的项，不设置时以web页面上的设置为准 'backtest': { 'start_date': 20180702, # 回测开始日期 'end_date': 20181101, # 回测结束日期 'slippage': 1, # 设置滑点,取值为整数,标的价格浮动最小单位值的整数倍 # 设置账户初始资金 'cash': { 'CS': 1000000, # 设置股票账户资金 'CF': 0 # 设置期货账户资金 } }, # 选填：仅模拟盘/实盘生效的项 'realtime': { 'pre_market_time': '8:50', # 设置开盘前回调on_before_market_open响应事件时间，默认为web页面上设置的时间 'closing_time': '14:55', # 设置收盘前最后一次回调on_bar或on_handle_data响应事件时间，默认为web页面上设置的时间 'group_timeout': 10000, # 设置group模式下的组播，等待多少ms则强制响应，默认为5000ms 'timer_cycle': 60000 # 设置onTimer响应时间(ms), 为0则不响应onTimer，默认情况下不回调onTimer } } } etasdk.load_config_json(config).start() # 必要：每个交易日回测/模拟/实盘前要做的操作 def on_before_market_open(api, date_now): # 必要：获取当个交易日需关注的股票 # 设置今天关注的股票，如果股票池中只有一只股票，则全部关注即可；股票池中股票过多时，需要先选股在设置部分关注以提高运行效率 api.context.pool.focus = api.context.pool.all # 必要：每天回测/交易 策略 两种方式回调 on_bar/on_handle_data # 用日K做回测，所以每天只会进入一次，收盘时响应此函数 # 策略逻辑：第一天买入，第二天卖出；判断逻辑，如果当前有仓位，则平仓，如果当前没有仓位，则买入 def on_bar(api, bar): symbol_positions = api.get_symbol_positions() # 获取持仓标的信息 if symbol_positions: # 如果持仓数大于0 # 平仓 log.info(\"target position zero!\") api.target_position(symbol=bar.symbol, qty=0) # 卖出 ，symbol = 选中标的，数量变为0 else: # 市价下单1000股 log.info(\"target position 1000!\") api.target_position(symbol=bar.symbol, qty=50000) # 买入 symbol = 选中标的，直至持仓数达500股 # 定时器，模拟盘响应；回测时可忽略 def on_timer(api): pass # 策略终止时响应；回测运行终止时会调用一次, exit_info返回值为终止消息 def on_terminate(api, exit_info): log.info(\"***************onTerminate*********\") # 输出日志 buySellFutures-期货买卖策略 #!/usr/bin/env python # -*- coding: utf-8 -*- ''' 期货策略：买卖策略 本策略是一个简单的期货买卖策略，主要是体现期货简单买卖 更多详情请看帮助文档：http://quant.upchina.com/doc/first.html ''' from etasdk import * if __name__ == '__main__': config = { \"host\": \"120.55.22.60\", \"port\": 80, \"user\": \"SDK-User\", # Web端：点击量化平台右上角用户名可查看填写 \"token\": \"SDK-Token\", # Web端：点击量化平台右上角用户名可查看填写 \"strategy_name\": \"buySellFutures\", # Web端：策略名称 \"console\": 0, \"loglevel\": \"ERROR\", # 显示日志级别，具体可查看帮助文档 \"instance_id\": \"20180605-165138-917-002BI\", # Web端：回测记录中本策略的回测ID,点击复制ID,粘贴此处即可 # 初始化参数 \"initialize\": { # symbols里设置单个股票或者其他有效的标的 # symbol_sets里设置标的集合，如此处的IF.PRD指的就是IF品种的所有标准合约，不包含IFZ0.CF和IFZ1.CF # 注：symbols和symbol_sets不能全部为空 'symbols': ['IFZ0.CF'], 'symbol_sets': ['IF.PRD'], # fields缓存的因子 # 'fields': ['FUT_TRADE_RANK', 'FUT_SHORT_RANK', 'FUT_LONG_RANK', 'STK_HOLD_DET', 'STK_HOLD_STAT', 'ST_STA','LIST_STA', 'TRADE_STA', 'NET_PROFIT', 'PB', 'PE', 'PS', 'PE_TTM'], # 必填：设置所需k线类型，interval可以选取1分钟，5分钟，15分钟，30分钟，60分钟，日k，Tick级别，count为提前缓存的数目 'prepared_bars': [{'interval': ETimeSpan.MIN_5, 'count': 100}], # 选填：设置撮合参数 interval为撮合周期，time_ranges为日内撮合时间段，将只在指定时间段以interval周期回调on_bar或on_handle_date 'match_param': { 'interval': ETimeSpan.MIN_5, # 'time_ranges': [('12:00', '14:45'), ('10:10', '11:00')] }, 'mode': 'both', # 选填：为group_only，则只响应on_handle_data；为single_only，则只响应on_bar；为both，则两个回调同时响应 'commission': 0.0002, # 选填：设置手续费 # 选填：仅回测生效的项，不设置时以web页面上的设置为准 'backtest': { 'start_date': 20180629, # 回测开始日期 'end_date': 20181228, # 回测结束日期 'slippage': 1, # 设置滑点,取值为整数,标的价格浮动最小单位值的整数倍 # 设置账户初始资金 'cash': { 'CS': 0, # 设置股票账户资金 'CF': 1000000 # 设置期货账户资金 } }, # 选填：仅模拟盘/实盘生效的项 'realtime': { 'pre_market_time': '19:00', # 设置开盘前回调on_before_market_open响应事件时间，默认为web页面上设置的时间 'closing_time': '14:55', # 设置收盘前最后一次回调on_bar或on_handle_data响应事件时间，默认为web页面上设置的时间 'group_timeout': 10000, # 设置group模式下的组播，等待多少ms则强制响应，默认为5000ms 'timer_cycle': 60000 # 设置onTimer响应时间(ms), 为0则不响应onTimer，默认情况下不回调onTimer } } } etasdk.load_config_json(config).start() def on_before_market_open(api, date_now): print(date_now.date) \"\"\" 必要：每个交易日回测/模拟/实盘前需要响应的事件 :param api: :param trade_now: :return: \"\"\" api.futures_code = api.get_continuous_symbol(\"IFZ0.CF\") # 获得当前交易日IF主力合约代码 print(api.futures_code) api.context.pool.focus = [api.futures_code, 'IFZ0.CF'] def on_handle_data(api, time_now): \"\"\" 仅当mode为group_only和both时响应该事件 on_handle_data在Focus标的收齐时或者超时时响应 必要：每天回测/交易 策略 可选择两种方式 on_bar/on_handle_data 策略逻辑：如果价格低于前一日收盘价的0.2%则开多，止盈0.5%止损0.3% :param api: :param time_now: EtaTime :return: \"\"\" print('------------------%s-------------------' % time_now[\"%Y%m%d %H:%M\"]) symbol_positions = api.get_symbol_positions() # 获取持仓标的信息 bars = api.get_bars_history(symbol=api.futures_code, time_span=ETimeSpan.MIN_5, count=1, price_mode=EPriceMode.FORMER, skip_suspended=0) # 获得合约当前bar数据 factor = bars['preClose'] / bars['open'] # 当前开盘价与昨日收盘价之比 # print(factor, bars['preClose'], bars['open']) # print(symbol_positions) if symbol_positions: # 如果有持仓 if api.futures_code == symbol_positions[0].symbol: # 当前持仓为主力合约 # 止盈0.3%止损0.5% if symbol_positions[0].posHigh / symbol_positions[0].posPrice > 1.03 \\ or symbol_positions[0].posLow / symbol_positions[0].posPrice MA-双均线策略（股票） 本示例演示双均线策略，股票池为沪深300，实现逻辑为：当5日均线上穿60日均线，买入；当5日均线下穿60日均线，卖出 #!/usr/bin/env python # -*- coding: utf-8 -*- from etasdk import * import time from datetime import datetime from etasdk.utils.time_util import TimeUtil import numpy as np ''' #本示例演示双均线策略，股票池为上证50 #策略逻辑： #1.当5日均线上穿60日均线，买入 #2.当5日均线下穿60日均线，卖出 回测标的：上证50 回测周期：20180702-20181101 撮合周期：日K ''' long_period = 60 short_period = 5 coefficient=0.06 #初始化 def onInitialize(api): #设置计算MACD需要的历史K线，为日K，最多历史上30根 api.setRequireBars(ETimeSpan.DAY_1,long_period); #设置安组回调模式，超时时间为 10S api.setGroupMode(10000); #设计模拟盘Timer函数的定时回调 api.setTimerCycle(60000) #设置股票池为沪深300 api.setSymbolPool(instsets=[\"000016.IDX\"]) #盘前运行，必须实现，用来设置当日关注的标的 def onBeforeMarketOpen(api,tradeDate): #取出股票池 symbolPool=api.getSymbolPool() # 备选买入清单 buy_list = [] # 卖出清单 sell_list = [] #遍历股票池，分别获取5和60 的K线 for i, symbol in enumerate(symbolPool): bars = api.getBarsHistory(symbol, ETimeSpan.DAY_1, long_period,priceMode=EPriceMode.FORMER, df=True,fields=['close']); if len(bars) == long_period: bar_close_long = bars[0:long_period] bar_close_short = bars[long_period-short_period:long_period] long_mean = np.mean( np.array(bar_close_long['close']) )# 计算60日均线 short_mean = np.mean( np.array(bar_close_short['close']) )# 计算5日均线 #print data , symbol,short_mean,long_mean ,\"|\",(short_mean - long_mean) ,coefficient* long_mean #如果 buy_flag = True if (short_mean - long_mean) > coefficient* long_mean else False if buy_flag: buy_list.append(symbol) else: sell_list.append(symbol) # 关注当前的buy_list即可，因为如果有持仓会自动关注 api.setFocusSymbols(buy_list); #获取当前持仓的标的，如果需要卖出，则平仓 position_symbols = api.getPositionSymbols(); # 输出当前交易日 LOG.INFO (\"[%s] buy list = [%s]\" ,tradeDate,buy_list) LOG.INFO (\"[%s] position_symbols list = [%s]\" , tradeDate,position_symbols) #如果买入列表的标的没有仓位则买入 for i, buy_symbol in enumerate(buy_list): if buy_symbol not in position_symbols: LOG.INFO(\"[%s] target position long 1000![%s]\", tradeDate,buy_symbol); api.targetPosition(symbol=buy_symbol, qty=1000) #卖出有卖出信号的标的 for i, pos_symbol in enumerate(position_symbols): if pos_symbol in sell_list: LOG.INFO(\"[%s] target position short 0![%s]\", tradeDate,pos_symbol); api.targetPosition(symbol=pos_symbol, qty=0); #Bar回调 def onHandleData(api,bar): pass; #定时器，模拟盘响应 def onTimer(api): pass; #策略终止时响应 def onTerminate(api,exitInfo): LOG.INFO (\"***************onTerminate*********\") 进阶股票策略 buyDemo-带参数的买入策略（股票） 本策略是一个简单的下单策略，主要是体现如何调用策略参数 ，方便策略参数较多时无需修改策略代码直接进行合理的参数优化管理。 需要在web平台中策略中的参数进行设置，具体步骤为：策略管理>-参数设置>-添加基础参数，如下图所示： #!/usr/bin/env python # -*- coding: utf-8 -*- #回测周期为20180702-20180719 #撮合周期：日K from etasdk import * import time from datetime import datetime def onInitialize(api): print(\"onInitialize\") #获取命令行参数 api.bar_len = 10 api.setRequireData( symbols=['000001.CS'], bars=[ (ETimeSpan.DAY_1, api.bar_len)] ) #获取策略参数 #需在web平台策略管理>-参数设置>-添加基础参数 # 参数名称：capital ； 参数类型 SFT_LONG； 默认值（自行选择）10000000；是否必填（自行选择）非必填 api.capital = api.getValueAsDouble(field=\"capital\") def onBeforeMarketOpen(api, data): time = api.timeNow() print(\"time----\",data) symbolPool = api.getSymbolPool() api.setFocusSymbols(symbolPool) def onBar(api, bar): print(\"onbar: %d\"%bar.tradeDate) hisBar=api.getBarsHistory(bar.symbol, ETimeSpan.DAY_1, api.bar_len, skipSuspended=1, df=True,priceMode = EPriceMode.FORMER) close=hisBar[\"close\"].mean() current_price = hisBar[\"close\"][api.bar_len-1] cash=api.capital #用获取的资金计算可下单数量，取100的整数倍 qty = int(0.8 * cash / current_price / 100) * 100 if current_price >close: api.targetPosition(bar.symbol, qty) def onTerminate(api, exit_info): LOG.INFO(\"onTerminate\") print(exit_info) multiFactor-多因子选股（股票） 本策略为股票多因子选股，通过Fama-French三因子模型对每只股票进行回归，得到其alpha值, 买入alpha为负的股票 #!/usr/bin/env python # -*- coding: utf-8 -*- from etasdk import * import numpy as np import pandas as pd import math ''' 股票策略：多因子选股 本策略根据Fama-French三因子模型对每只股票进行回归，得到其alpha值, 买入alpha为负的股票。 策略思路： 计算市场收益率,并对个股的账面市值比和市值进行分类, 根据分类得到的组合计算市值加权收益率、SMB和HML. 对各个股票进行回归(无风险收益率等于0)得到alpha值. 选取alpha值小于0并为最小的10只股票进入标的池 等权买入在标的池的股票并卖出不在标的池的股票 回测数据:000300.IDX的成份股 回测区间：2018-07-01 到2018-10-01 回测周期：日K ''' #初始化 def onInitialize(api): # 数据滑窗 api.dataWindow = 20 # 设置开仓的最大资金量 api.ratio = 0.8 # 账面市值比的大/中/小分类 api.BM_BIG = 3.0 api.BM_MID = 2.0 api.BM_SMA = 1.0 # 市值大/小分类 api.MV_BIG = 2.0 api.MV_SMA = 1.0 # 持仓股票 api.symbols_pool = [] # 设置股票池，因子以及K线类型 api.setRequireData(instsets=[\"000300.IDX\"], # 000300成分股 fields=['MKT_CAP', \"PB\"], bars=[(ETimeSpan.DAY_1, api.dataWindow + 10)] ) #设置按组回调 api.setGroupMode(timeOutMs=10000,onlyGroup = False); #盘前运行，用于选股逻辑；必须实现，用来设置当日关注的标的 def onBeforeMarketOpen(api,tradeDate): print(\"on date\", tradeDate) # 获取股票池 symbolPool = api.getSymbolPool() fundamentalDf = pd.DataFrame(columns=[\"symbol\", 'MKT_CAP', \"PB\"]) # 获取基本面数据 for symbol in symbolPool: # 检查股票是否停牌，不交易停牌股票 if api.isSuspend(symbol, tradeDate): continue # 获取基本面数据 fundamentals = api.getFieldsCountDays(symbol=symbol, fields=['MKT_CAP', \"PB\"], count=api.dataWindow + 1) fundamentalDf.loc[len(fundamentalDf)] = {\"symbol\": symbol, \"MKT_CAP\": fundamentals.MKT_CAP.values[0], \"PB\": fundamentals.PB.values[0]} # 计算账面市值比, PB倒数 fundamentalDf[\"PB\"] = (fundamentalDf['PB'] ** -1) # 计算市值的50%的分位点, 用于分类 sizeGate = fundamentalDf['MKT_CAP'].quantile(0.50) # 计算账面市值比的30%和70%分位点,用于分类 bm_gate = [fundamentalDf['PB'].quantile(0.30), fundamentalDf['PB'].quantile(0.70)] fundamentalDf.index = fundamentalDf.symbol x_return = [] # 计算return tickerCloseValues = {} for symbol in fundamentalDf.symbol.values: price = api.getBarsHistory(symbol, timeSpan=ETimeSpan.DAY_1, count=api.dataWindow + 1, df=True, \\ priceMode=EPriceMode.FORMER, skipSuspended=0) if len(price) stockTiming-股票择时（股票） # coding=utf-8 from __future__ import print_function, absolute_import, unicode_literals, division import numpy as np from etasdk import * from talib import EMA ''' 本策略为股票个股择时，等资金分配仓位。 回测参数设置： 1、回测时间：2014-01-06到2018-11-08； 2、撮合周期：日K； 3、费率：万3 4、滑点：1个tick 5、股票初始资金：100万 6、股票池：上证50 ''' def capital_lots(close, capital,ratio_by_index): ## 计算下单股数 # input:价格、资金和仓位比例（0-100%） volume = {} capitalSingle = ratio_by_index * capital / len(close) # 均分后根据指数计算仓位比例 for symbol in close.keys(): volume[symbol] = max(100*int(capitalSingle / (close[symbol] * 100.)),100) # 不足1手，补齐1手 return volume def onInitialize(api): ## 设置标的 api.index = str(\"000016.IDX\") # 以上证50股票池为例 api.setSymbolPool(instsets=[api.index], symbols=[api.index]) api.setGroupMode(50000, True) ## 全局参数 api.dataLen = 200 # 每次下载的数据长度 api.setRequireBars(ETimeSpan.DAY_1, api.dataLen) account = api.getAccount(symbol=api.index, market=MARKET_CHINASTOCK) api.capital = account.cashAvailable # 账户初始资金（100万） ## 时间窗口参数 api.windows_SMA = 5 # 短期移动平均窗口 api.windows_LMA = 20 # 长期移动平均窗口 api.windows_LLMA = 120 # 更长周期移动平均窗口 ## 临界值类 api.stop_method = 1 ## 行情数据类 api.tradeday = [] # 交易日 api.symbolPool = [] api.price = None # 交易信号 print(\"initialize successly.\") LOG.INFO(\"initialize successly.\") def onBeforeMarketOpen(api, trade_date): print(\"-------------------\") print(\"tradingday:\", trade_date) LOG.INFO(\"tradingday:%s\", trade_date) api.tradeday.append(trade_date) api.symbolPool = api.getSymbolPool() ## 止损平仓 stop_loss(api) ## 1、择时与选股 api.price = timeAlgorithm(api) # 修改择时算法，返回选股的价格（字典形式） print(\"trade symbol:\", api.price.keys()) # 设置当天需要交易的股票，如果历史上有过持仓了，则系统会默认自动关注 api.setFocusSymbols(api.price.keys()) # 根据持仓信息，处理持仓股票。平掉不在信号池中的股票 symbolpositions = api.getSymbolPositions() print(\"symbol before close\", len(symbolpositions)) for position in symbolpositions: if api.isSuspend(position.symbol, api.getCurrTradeDate()): continue if position.symbol not in api.price.keys(): api.targetPosition(symbol=position.symbol, qty=0, positionSide=EPositionSide.LONG, remark=\"not in signal pool\") def onHandleData(api, timeExch): # 当前信号不为空 if not api.price or len(api.price) == 0: return # 获取账户信息，根据剩余可用现金和持仓信息，计算新开仓量 ratio_by_index = 0.9 # %90%仓位，可根据大盘走势进行调整 account = api.getAccount(symbol=api.index, market=MARKET_CHINASTOCK) capital = account.totAssets * ratio_by_index - account.marketValue # 获取止损和平仓后的持仓 holdingPos = [] symbolpositions = api.getSymbolPositions() for position in symbolpositions: holdingPos.append(position.symbol) newSymbols = list(set(api.price.keys()) - set(holdingPos)) # 检查是否有新标的需要买入 if len(newSymbols) == 0: return # 计算个股capital eachTickerCapital = capital / len(newSymbols) # 根据个股capital下单 for symbol in newSymbols: # 获取标的当前价格 price = api.getBarsHistory(symbol, timeSpan=ETimeSpan.DAY_1, count=1, df=True,\\ priceMode=EPriceMode.FORMER, skipSuspended=0) if len(price) closeLMA) else 0 volume = HQData.volume.values volumeMA = EMA(volume[:-1],20) closeSMADouble08 = EMA(EMA(close, 8), 8) dailyRet = np.log(closeSMADouble08[-1]) - np.log(closeSMADouble08[-2]) signal = 1 if (volume[-1] > 2.*volumeMA[-1]) and (dailyRet>0) else signal01 return signal def stop_loss(api): # 移动止损止盈 positionQty, positionHigh, positionClose = queryPosition(api) for ind in positionQty.keys(): # 检查标的是否停牌 if api.isSuspend(ind, api.getCurrTradeDate()): continue hist_data = api.getBarsHistory(ind, timeSpan=ETimeSpan.DAY_1, count=90, df=True, priceMode=EPriceMode.FORMER) if len(hist_data) >= 60: close = hist_data.close.values if api.stop_method == 1: # 止损 drawdown = np.log(positionHigh[ind] / positionClose[ind]) if drawdown = 0.15): api.targetPosition(symbol=ind, qty=0, positionSide=EPositionSide.SHORT) print(api.tradeday[-1], \",stop return\", ind) def queryPosition(api): # # 查询持仓 positionQty = {} positionHigh = {} positionClose = {} symbolpositions = api.getSymbolPositions() if not symbolpositions: return positionQty,positionHigh,positionClose else: for ind in symbolpositions: positionQty[ind.symbol] = ind.posQty positionHigh[ind.symbol] = ind.posHigh positionClose[ind.symbol] = ind.posPrice return positionQty,positionHigh,positionClose industryRotation-行业轮动（股票） #!/usr/bin/env python # -*- coding: utf-8 -*- from etasdk import * import numpy as np from operator import itemgetter from collections import OrderedDict ''' 股票策略：行业轮动 本策略每天计算\"880008.PLA\", \"880023.PLA\", \"880030.PLA\", \"880035.PLA\", \"880046.PLA\", \"880064.PLA\" (化学制品.电子.纺织服装.医药.房地产.国防军工)这几个行业指数过去 20个交易日的收益率,选取收益率最高的指数的成份股中流通市值最大的5只股票作为下期的持仓股票 对不在股票池的股票平仓并等权配置股票池的标的 回测区间：2018-07-01 到2018-10-01 撮合周期：日K ''' #初始化 def onInitialize(api): # 选取行业板块 # 这里我们选择 化学制品（880008.PLA）， 电子（\"880023.PLA\"），纺织服装（\"880030.PLA\"）， 医药（\"880035.PLA\")，房地产（\"880046.PLA\"），国防军工（\"880064.PLA\"） api.industries = [\"880008.PLA\", \"880023.PLA\", \"880030.PLA\", \"880035.PLA\", \"880046.PLA\", \"880064.PLA\"] api.returnWindow = 20 api.capitalRatio = 0.8 api.numberOfChosenTickers = 5 api.chosenTickers = [] # 设置股票池，因子以及K线类型 api.setRequireData(instsets=api.industries, symbols=api.industries, # 单独订阅行情数据 fields=['MKT_CAP'], bars=[(ETimeSpan.DAY_1, api.returnWindow + 10)] ) #设置按组回调 api.setGroupMode(timeOutMs=10000,onlyGroup = False); #盘前运行，用于选股逻辑；必须实现，用来设置当日关注的标的 def onBeforeMarketOpen(api,tradeDate): print(\"on date\", tradeDate) # 计算各个行业指数的return return_index = [] for industry in api.industries: bars = api.getBarsHistory(industry, timeSpan=ETimeSpan.DAY_1, count=api.returnWindow + 1, df=True, priceMode=EPriceMode.FORMER, skipSuspended=0) bars.fillna(method=\"ffill\") if len(bars) index_hedge_alpha-指数对冲（股票+期货） #!/usr/bin/env python # -*- coding: utf-8 -*- from __future__ import print_function, absolute_import, unicode_literals,division from etasdk import * ''' 指数对冲策略 策略基本思想：本策略为股票市场中性策略，即股票多头+股指期货空头，二者在换仓日保持市值相等。 策略交易频率：每月换仓一次 交易或订阅标的：沪深300指数的成分股和沪深300指数期货，从沪深300指数成分股中按照动量和估值选出30只较强的股票。 回测时间：2016-12-01 到2017-12-29 撮合频率：日K 初始资金：A股200万，期货200万 ''' def onInitialize(api): #设置股票池 api.setSymbolPool(instsets=[\"IF.PRD\",\"000300.IDX\"]) # 设置数据下载的超时时间 api.setGroupMode(500, True) # 设置行情数据缓存条数 api.data_len = 21 api.setRequireBars(ETimeSpan.DAY_1,api.data_len) # 设置缓存日频因子数据 api.setRequireFields(fields=[\"PE\"]) api.stock_num = 30 api.trade_day_now = 0 api.trade_day_last = 0 api.lots_stock = {} api.futures_code = [] api.lots_futures = 0 def onBeforeMarketOpen(api,trade_date): print (\"date：\",trade_date) # 订阅的标的代码 symbol_subscribe = api.getSymbolPool() data_code = [ind01 for ind01 in symbol_subscribe if \"CS\" in ind01] api.futures_code = api.getContinuousSymbol(\"IFZ0.CF\", trade_date) data_code.append(str(api.futures_code)) # 关注相关股票和股指期货 # api.setFocusSymbols(data_code) # 当前股指期货主力合约代码 api.futures_code = api.getContinuousSymbol(\"IFZ0.CF\", trade_date) # 获取当前交易日 api.trade_day_now = api.getCurrTradeDate() # 获取上一交易日 api.trade_day_last = api.getPrevTradeDate(trade_date) # 如果当前是每月的第一个交易日即选股调仓并执行对冲 # if str(api.trade_day_now)[4:6] == str(api.trade_day_last)[4:6]: return # 获取股票的PE指标数据 findata = api.getFieldsOneDay(data_code[:-1], [\"PE\"],api.trade_day_last, df=True) findata.index = findata[\"symbol\"] # 获取历史行情数据 close = {} for ind03 in data_code: bars = api.getBarsHistory(ind03, ETimeSpan.DAY_1, count=api.data_len, priceMode=EPriceMode.FORMER, df=True) if (len(bars) >= api.data_len) and (bars.ix[api.data_len-1,\"isSuspended\"] == 0): close[ind03] = bars.ix[api.data_len - 1, \"close\"] if (\"CS\" in ind03): findata.ix[ind03,\"momentum01\"] = (bars.ix[api.data_len-1,\"close\"]/bars.ix[0,\"close\"])-1 # 先按照估值PE和动量排序选出前30只股票 findata[[\"ranks_pe\",\"rank_mom\"]] = findata.rank()[[\"PE\",\"momentum01\"]] findata[\"score\"] = findata[\"rank_mom\"]-findata[\"ranks_pe\"] findata_sorted = findata.sort_values(\"score\",ascending=False)[:api.stock_num] symbol_stock = list(findata_sorted.index.values) symbol_stock.append(api.futures_code) # 关注相关股票和股指期货 api.setFocusSymbols(symbol_stock) symbolpositions = api.getSymbolPositions() # 每天判断是否需要换仓 for ind in symbolpositions: if ind.symbol not in symbol_stock: if ind.positionSide == EPositionSide.LONG: # 股票不在关注的标的中，卖出 api.targetPosition(symbol=ind.symbol, qty=0, positionSide=EPositionSide.LONG) elif ind.positionSide == EPositionSide.SHORT: # 期货在换月时刻，近月合约平仓 api.targetPosition(symbol=ind.symbol, qty=0, positionSide=EPositionSide.SHORT) api.targetPosition(symbol=api.futures_code, qty=ind.posQty, positionSide=EPositionSide.SHORT) print(\"Shifting positions for months，close market positions：\", ind.symbol) # 平均分配每只股票资金，计算每只股票仓位 api.lots_stock = {} account_stock = api.getAccount(data_code[0]) capital = account_stock.cashAvailable + account_stock.marketValue for ind05 in close.keys(): if (\"CS\" in ind05) and (ind05 in symbol_stock): api.lots_stock[ind05] = int(capital*0.70/close[ind05]/api.stock_num/100.0)*100 elif (\"CF\" in ind05) : api.lots_futures = int(capital*0.70/close[ind05]/300.0) # 1、获取当前仓位换仓 for ind04 in symbolpositions: symbol_last = ind04.symbol # 不在标的的股票将卖出 if (\"CS\" in symbol_last) and (symbol_last not in symbol_stock): api.targetPosition(symbol=symbol_last, qty=0) print(\"not in symbolPool，close market positions：\", symbol_last) def onHandleData(api, timeExch): # 如果当前是每月的第一个交易日即选股调仓并执行对冲 if str(api.trade_day_now)[4:6] == str(api.trade_day_last)[4:6]: return # 2、买入标的池股票 for ind06 in api.lots_stock.keys(): # 如果股票有分红送股的情况下，增加仓位也需要时 100 的整数倍 currentShares = api.getSymbolPosition(ind06).posQty addShares = ((api.lots_stock[ind06] - currentShares + 50) // 100) * 100 totalShares = currentShares + addShares api.targetPosition(symbol=ind06, qty=totalShares) print(\"open market positions：\", ind06, totalShares) # 开空股指期货对冲 api.targetPosition(symbol=api.futures_code, qty=api.lots_futures, positionSide=EPositionSide.SHORT) print(\"open market short positions：\", api.futures_code) def onTerminate(api,exitInfo): print(\"onTerminate\") 精通股票策略 machineLearning-机器学习（股票） #!/usr/bin/env python # -*- coding: utf-8 -*- from __future__ import print_function, absolute_import from etasdk import * import numpy as np from datetime import datetime import sys try: from sklearn import svm except: print('please install scikit-learn and numpy with mkl') sys.exit(-1) ''' 股票策略：机器学习 本策略选取了七个特征变量组成了滑动窗口长度为20天的训练集, 训练了一个二分类的支持向量机模型来预测股票的上涨和下跌. 若每个星期一没有仓位则计算标的股票近20个交易日的特征变量进行预测,并在预测结果为上涨的时候购买标的. 若已经持有仓位则在盈利大于10%的时候止盈,在星期五损失大于2%的时候止损. 特征为:1.收盘价/均值2.现量/均量3.最高价/均价4.最低价/均价5.现量6.区间收益率7.区间标准差 训练数据为:600036.CS招商银行,时间从20170507到20171107 回测时间为:20171108-20181101 撮合周期：日K ''' #初始化 def onInitialize(api): # 数据滑窗 # 回测时间20171108-20181101 api.train_start_date = 20170507 api.train_end_date = 20171107 api.trainFinished = False api.symbol = \"600036.CS\" # 订阅招商银行股票 api.ratio = 0.8 api.dataWindow = 20 api.clf = None # 设置股票池，因子以及K线类型 api.setRequireData(symbols=[api.symbol], bars=[(ETimeSpan.DAY_1, 1000)]) #设置按组回调 api.setGroupMode(timeOutMs=10000, onlyGroup = False); # train def trainHistoryData(api): # 获取目标股票的daily历史行情 recent_data = api.getBarsHistory(api.symbol, timeSpan=ETimeSpan.DAY_1, count=1000, df=True, \\ priceMode=EPriceMode.FORMER, skipSuspended=0) recent_data.fillna(method=\"ffill\") # 获取目标股票的训练数据集 recent_data = recent_data[(recent_data[\"tradeDate\"] >= api.train_start_date) & (recent_data[\"tradeDate\"] = start_day) &(recent_data[\"tradeDate\"] days_close[i + api.dataWindow]: label = 1 else: label = 0 y_all.append(label) x_train = x_all[: -1] y_train = y_all[: -1] # 训练SVM api.clf = svm.SVC(C=1.0, kernel=str('rbf'), degree=3, gamma=str('auto'), coef0=0.0, shrinking=True, probability=False, tol=0.001, cache_size=400, verbose=False, max_iter=-1, decision_function_shape=str('ovr'), random_state=None) print(x_train, y_train) api.clf.fit(x_train, y_train) #print('finished training!') #盘前运行，用于选股逻辑；必须实现，用来设置当日关注的标的 def onBeforeMarketOpen(api,tradeDate): print(\"on date\", tradeDate) # 设置当天需要交易的股票，如果历史上有过持仓了，则系统会默认自动关注 api.setFocusSymbols(api.symbol) # firstly time to run, need to train the system if not api.trainFinished: trainHistoryData(api) api.trainFinished = True # 当前工作日 weekday = datetime.strptime(str(tradeDate), '%Y%m%d').isoweekday() # 获取持仓 symbolposition = api.getSymbolPosition(api.symbol) # 获取预测用的历史数据 data = api.getBarsHistory(api.symbol, timeSpan=ETimeSpan.DAY_1, count=api.dataWindow, df=True, \\ priceMode=EPriceMode.FORMER, skipSuspended=0) data.fillna(method=\"ffill\") # 如果是新的星期一且没有仓位则开始预测 if not symbolposition or symbolposition.posQty == 0 and weekday == 1: close = data['close'].values train_max_x = data['high'].values train_min_n = data['low'].values train_amount = data['totalVolume'].values volume = [] for i in range(len(close)): volume_temp = train_amount[i] / close[i] volume.append(volume_temp) close_mean = close[-1] / np.mean(close) volume_mean = volume[-1] / np.mean(volume) max_mean = train_max_x[-1] / np.mean(train_max_x) min_mean = train_min_n[-1] / np.mean(train_min_n) vol = volume[-1] return_now = close[-1] / close[0] std = np.std(np.array(close), axis=0) # 得到本次输入模型的因子 features = [close_mean, volume_mean, max_mean, min_mean, vol, return_now, std] features = np.array(features).reshape(1, -1) if api.clf: prediction = api.clf.predict(features)[0] else: print(\"[ERR]: train model is None\") # 获取账户信息 account = api.getAccount(api.symbol) totAssets = account.totAssets eachTickerCapital = totAssets * api.ratio # 若预测值为上涨则开仓 if prediction == 1: # 获取昨收盘价 price = close[-1] # 开仓 qty = int(eachTickerCapital / price / 100) * 100 api.targetPosition(symbol=api.symbol, qty=qty) print(api.symbol, 'open positions for qty of', qty) # 当涨幅大于10%,平掉所有仓位止盈 elif symbolposition and data.close.values[-1] / symbolposition.posPrice >= 1.10: if symbolposition.posQty != 0: api.targetPosition(symbol=api.symbol, qty=0) print('stop win, close positions for', api.symbol) # 当时间为周五并且跌幅大于2%时,平掉所有仓位止损 elif symbolposition and data.close.values[-1] / symbolposition.posPrice intradayStockTrade-日内回转交易（股票） #!/usr/bin/env python # -*- coding: utf-8 -*- from __future__ import print_function, absolute_import, unicode_literals,division from etasdk import * import numpy as np from pandas import DataFrame import sys try: import talib except: print('please install TA-Lib') sys.exit(-1) ''' 本策略为股票日内回转交易。 1、首先买入600000.CS股票10000股底仓； 2、根据分钟数据计算MACD(12,26,9)： 在MACD>0的时候买入100股;在MACD 0 and api.availableQty.availableQty > 0 : # 获取时间序列数据 recent_data = api.getBarsHistory(api.symbol, timeSpan=ETimeSpan.MIN_1, count=api.init_data_len, df=True,priceMode=EPriceMode.FORMER,skipSuspended=0) # 计算MACD线 macd = talib.MACD(recent_data['close'].values)[0][-1] # 根据MACD>0则开仓,小于0则平仓 if macd > 0: # 多空单向操作都不能超过昨仓位,否则最后无法调回原仓位 if api.turnaround[0] + api.trade_n = 1455: print(\"recover position before close.\") symbolposition = api.getSymbolPosition (symbol=api.symbol,positionSide=EPositionSide.LONG) if symbolposition.posQty != api.total: api.targetPosition(symbol=bar.symbol, qty=api.total, positionSide=EPositionSide.LONG, remark=\"target position\") print(\"To target position:%d\" %(api.total)) api.ending = 1 # 更新过去的日期数据 api.tradeDate[-1] = api.tradeDate[0] 高阶经典期货策略 net_trade-网格交易（期货） 本策略为经典的期货日内策略（网格交易），设置不同的临界线，并分配不同的资金仓位 # coding=utf-8 from __future__ import print_function, absolute_import, unicode_literals,division from etasdk import * import numpy as np import pandas as pd ''' 策略基本思想：本策略为经典的期货日内策略（网格交易），设置不同的临界线，并分配不同的资金仓位。 策略交易频率：1分钟 交易或订阅标的：rb1801 回测时间：2017-12-01 到2017-12-29 ''' def onInitialize(api): #设置股票池 api.setSymbolPool(symbols=[\"rb1801.CF\"]) # 设置行情数据缓存条数 api.data_len = 100 api.setRequireBars(ETimeSpan.MIN_1,api.data_len) api.trade_product = str(\"rb1801.CF\") # 查询初始资金 account = api.getAccount(api.trade_product) api.capital = account.cashAvailable # 交易参数设定 api.k1 = [-40.0,-3.0,-2.0,2.0,3.0,40.0] api.weight = [0.5,0.3, 0.0, 0.3, 0.5] api.trade_peroid = 60 # 每小时更新一次网格临界线 api.minute_num = 0 api.level = 3.0 api.volume = [] api.band = [] def onBeforeMarketOpen(api, trade_date): print(trade_date) api.tradeday = trade_date ## 订阅行情 api.setFocusSymbols( api.trade_product) def onBar(api,data): if (api.minute_num % api.trade_peroid) == 0: # 获取过去300个数据计算临界线 data01 = api.getBarsHistory(data.symbol, timeSpan=ETimeSpan.MIN_1, count=api.data_len, df=False) close = [] for ind01 in data01: close.append(ind01.close) api.band = np.mean(close)+np.array(api.k1)*np.std(close) # 计算网格状态 grid = pd.cut([data.close],api.band,labels=[0,1,2,3,4])[0] print(grid) # 更新计算交易量 api.volume = [] for weight in api.weight: api.volume.append(lots(api, data, weight)) api.minute_num += 1 # 查询持仓 position_long = api.getSymbolPosition(symbol=data.symbol, positionSide=EPositionSide.LONG) position_short = api.getSymbolPosition(symbol=data.symbol, positionSide=EPositionSide.SHORT) if not position_short.posQty and not position_long.posQty and grid != 2: if grid >= 3: api.targetPosition(symbol=data.symbol, qty=api.volume[grid], positionSide=EPositionSide.LONG) print(\"open market long positions 1：\", data.symbol) if grid = 3: api.targetPosition(symbol=data.symbol, qty=api.volume[grid], positionSide=EPositionSide.LONG) print(\"open market long positions 2：\", data.symbol) elif grid == 2: api.targetPosition(symbol=data.symbol, qty=0, positionSide=EPositionSide.LONG) print(\"close market long positions：\", data.symbol) elif grid = 3: api.targetPosition(symbol=data.symbol, qty=0, positionSide=EPositionSide.SHORT) api.targetPosition(symbol=data.symbol, qty=api.volume[grid], positionSide=EPositionSide.LONG) print(\"close market short and open market long positions：\", data.symbol) def lots(api, data,weight): # 获取账户资金计算下单手数 refdata = api.getRefData(data.symbol) multiper = refdata.valuePerUnit return (int(api.capital * api.level*weight / data.close / multiper)) turtleTradingRule-海龟交易法（期货） #!/usr/bin/env python # -*- coding: utf-8 -*- from __future__ import print_function, absolute_import, unicode_literals import sys import numpy as np try: import talib except: print('please Install TA-Lib') sys.exit(-1) from etasdk import * ''' 期货策略：海龟交易法 本策略通过计算FG801.CF和rb1801.CF的ATR.唐奇安通道和MA线, -- 当价格上穿唐奇安通道且短MA在长MA上方时开多仓; -- 当价格下穿唐奇安通道且短MA在长MA下方时开空仓(8手) 若有多仓则在价格跌破唐奇安平仓通道下轨的时候全平仓位,否则根据跌破 持仓均价 - x(x=0.5,1,1.5,2)倍ATR把仓位平至6/4/2/0手 若有空仓则在价格涨破唐奇安平仓通道上轨的时候全平仓位,否则根据涨破 持仓均价 + x(x=0.5,1,1.5,2)倍ATR把仓位平至6/4/2/0手 撮合周期为:1分钟 回测时间为:2017-09-15 到2017-10-01 ''' def onInitialize(api): print(\"analyzer initialize\") # 设置响应模式 api.setGroupMode(5000, False) # 设置关注的合约标的 api.tickersCode = [\"FG1801.CF\", \"rb1801.CF\"] # api.parameter 分别为唐奇安开仓通道.唐奇安平仓通道.短ma.长ma.ATR的参数 api.parameter = [55, 20, 10, 60, 20] api.tar = api.parameter[4] api.data_len = 600 api.setSymbolPool(symbols=api.tickersCode) api.setRequireBars(ETimeSpan.MIN_1, api.data_len) # 初始资金和数据测试 account = api.getAccount(symbol=api.tickersCode[0], market=MARKET_CHINAFUTURE) api.capital = account.cashAvailable # 账户初始资金 api.canTrade = True def onBeforeMarketOpen(api, tradeDate): api.trading_day = tradeDate # 订阅行情 api.setFocusSymbols(api.tickersCode) # 获取账户盈亏信息，如果亏损超过初始资金一半，不再开仓 getStrategyPnL = api.getStrategyPnL() cumpnl_raw = api.capital + getStrategyPnL.overallPnL if cumpnl_raw upper_band and (diff > 0): api.targetPosition(symbol=bar.symbol, qty=8, positionSide=EPositionSide.LONG) print(bar.symbol, 'Open 8 Long-shares at market position') # 下穿唐奇安通道且短ma在长ma下方则开空仓 if bar.low upper_band: api.targetPosition(symbol=bar.symbol, qty=0, positionSide=EPositionSide.SHORT) print(bar.symbol, 'Close all Short-positions') else: # 获取持仓均价 vwap = position_long.posPrice # 根据持仓以来的最高价计算不同的止损价格带 band = vwap + np.array([2, 1.5, 1, 0.5]) * atr # 计算最新应持仓位 if bar.close >= band[0]: api.targetPosition(symbol=bar.symbol, qty=0, positionSide=EPositionSide.SHORT) print(bar.symbol, 'Short target positions to 0 shares') elif band[0] > bar.close >= band[1]: api.targetPosition(symbol=bar.symbol, qty=2, positionSide=EPositionSide.SHORT) print(bar.symbol, 'Short target positions to 2 shares') elif band[1] > bar.close >= band[2]: api.targetPosition(symbol=bar.symbol, qty=4, positionSide=EPositionSide.SHORT) print(bar.symbol, 'Short target positions to 4 shares') elif band[2] > bar.close >= band[3]: api.targetPosition(symbol=bar.symbol, qty=6, positionSide=EPositionSide.SHORT) print(bar.symbol, 'Short target positions to 6 shares') else: print(\"Accumulated losses exceed half of the initial funds, no longer open positions!\") return def onTerminate(api, exit_info): print(\"Finished test\") pass interCommoditySpread-跨市场套利（期货） # coding=utf-8 from __future__ import print_function, absolute_import, unicode_literals import datetime from etasdk import * import numpy as np ''' 期货策略：跨市场套利 本策略首先滚动计算过去30个1min收盘价的均值,然后用均值加减2个标准差得到布林线. 若无仓位,在最新价差上穿上轨时做空价差;下穿下轨时做多价差 若有仓位则在最新价差回归至上下轨水平内时平仓 回测数据为:rb1801和hc1801的1min数据 回测时间为:2017-09-01 到2017-09-29 撮合周期：1分钟 初始资金（期货）：10万 ''' def onInitialize(api): # 设置响应模式 api.setGroupMode(5000, False) # 设置bar长度 api.data_len = 30 # 进行套利的品种 api.tickersCode = ['rb1801.CF', 'hc1801.CF'] # \"rb1801.CF\"---螺纹1801合约 # 设置行情数据缓存 api.setRequireData(instsets=['rb.PRD', 'hc.PRD'], symbols=api.tickersCode, fields=[], bars=[(ETimeSpan.MIN_1, 300)]) def onBeforeMarketOpen(api,tradeDate): # print(tradeDate) api.trading_day = tradeDate # 订阅行情 api.setFocusSymbols(api.tickersCode) symbol_positions = api.getSymbolPositions() print(\"symbol_positions:\", symbol_positions) position_rb_long = api.getSymbolPosition(symbol=api.tickersCode[0], positionSide=EPositionSide.LONG) position_rb_short = api.getSymbolPosition(symbol=api.tickersCode[0], positionSide=EPositionSide.SHORT) def onHandleData(api, timeExch): api.trade_date = datetime.datetime.fromtimestamp(timeExch / 1000) # 获取两个品种的时间序列 data_rb = api.getBarsHistory(symbol=api.tickersCode[0], timeSpan=ETimeSpan.MIN_1, count=api.data_len+1, priceMode=EPriceMode.FORMER, fields=None, df=True) close_rb = data_rb[\"close\"].values data_hc = api.getBarsHistory(symbol=api.tickersCode[1], timeSpan=ETimeSpan.MIN_1, count=api.data_len+1, priceMode=EPriceMode.FORMER, fields=None, df=True) close_hc = data_hc[\"close\"].values # 计算价差 spread = close_rb[:-1] - close_hc[:-1] # 计算布林带的上下轨 up = np.mean(spread) + 2 * np.std(spread) down = np.mean(spread) - 2 * np.std(spread) # 计算最新价差 spread_now = close_rb[-1] - close_hc[-1] # 无交易时若价差上(下)穿布林带上(下)轨则做空(多)价差 position_rb_long = api.getSymbolPosition(symbol=api.tickersCode[0], positionSide=EPositionSide.LONG) position_rb_short = api.getSymbolPosition(symbol=api.tickersCode[0], positionSide=EPositionSide.SHORT) print(\"I'm here!\") print(position_rb_long) if not position_rb_long and not position_rb_short: if spread_now > up: api.targetPosition(symbol=api.tickersCode[0], qty=1, positionSide=EPositionSide.SHORT) LOG.INFO(\"Open short at market price:%s\", api.tickersCode[0]) api.targetPosition(symbol=api.tickersCode[1], qty=1, positionSide=EPositionSide.LONG) LOG.INFO(\"Open long at market price:%s\", api.tickersCode[1]) if spread_now = down: api.targetPosition(symbol=api.tickersCode[0], qty=0, positionSide=EPositionSide.SHORT) api.targetPosition(symbol=api.tickersCode[1], qty=0, positionSide=EPositionSide.LONG) LOG.INFO(\"Clear all positions\") # 突破上轨开多 if spread_now > up: api.targetPosition(symbol=api.tickersCode[0], qty=1, positionSide=EPositionSide.SHORT) LOG.INFO(\"Open short at market price:%s\", api.tickersCode[0]) api.targetPosition(symbol=api.tickersCode[1], qty=1, positionSide=EPositionSide.LONG) LOG.INFO(\"Open long at market price:%s\", api.tickersCode[1]) def onTerminate(api,exitInfo): print(\"Finished test\") calendarArbitrage-跨期套利（期货） # coding=utf-8 from __future__ import print_function, absolute_import, unicode_literals import sys import datetime import numpy as np from etasdk import * try: import statsmodels.tsa.stattools as ts except: print('please install statsmodels') sys.exit(-1) ''' 期货策略：跨期套利 本策略根据EG两步法(1.序列同阶单整2.OLS残差平稳)判断序列具有协整关系后(若无协整关系则全平仓位不进行操作) 通过计算两个价格序列回归残差的均值和标准差并用均值加减0.9倍标准差得到上下轨 在价差突破上轨的时候做空价差;在价差突破下轨的时候做多价差 若有仓位,在残差回归至上下轨内的时候平仓 回测数据为:rb1801和rb1805的1min数据 回测时间为:2017-09-25 到2017-10-01 撮合周期：1分钟 ''' def onInitialize(api): # 设置响应模式 api.setGroupMode(5000, False) # 设置bar长度 api.data_len = 800 # 进行套利的品种 api.tickersCode = ['rb1801.CF', 'rb1805.CF'] # 设置行情数据缓存 api.setRequireData(instsets=['rb.PRD'], symbols=api.tickersCode, fields=[], bars=[(ETimeSpan.MIN_1, 900)]) def onBeforeMarketOpen(api, tradeDate): # print(tradeDate) api.trading_day = tradeDate # 订阅行情 api.setFocusSymbols(api.tickersCode) def onHandleData(api, timeExch): api.trade_date = datetime.datetime.fromtimestamp(timeExch / 1000) # 获取两个品种的时间序列 data_01 = api.getBarsHistory(symbol=api.tickersCode[0], timeSpan=ETimeSpan.MIN_1, count=api.data_len + 1, priceMode=EPriceMode.FORMER, fields=None, df=True) close_01 = data_01[\"close\"].values data_02 = api.getBarsHistory(symbol=api.tickersCode[1], timeSpan=ETimeSpan.MIN_1, count=api.data_len + 1, priceMode=EPriceMode.FORMER, fields=None, df=True) close_02 = data_02[\"close\"].values # 展示两个价格序列的协整检验的结果 beta, c, resid, result = cointegration_test(close_01, close_02) # 如果返回协整检验不通过的结果则全平仓位等待 if not result: symbol_positions = api.getSymbolPositions() if symbol_positions: for symbol_obj in symbol_positions: if symbol_obj.positionSide == EPositionSide.SHORT: api.targetPosition(symbol=symbol_obj.symbol, qty=0, positionSide=EPositionSide.SHORT) LOG.INFO(\"close old contract short position:%s\", symbol_obj.symbol) elif symbol_obj.positionSide == EPositionSide.LONG: api.targetPosition(symbol=symbol_obj.symbol, qty=0, positionSide=EPositionSide.LONG) LOG.INFO(\"close old contract long position:%s\", symbol_obj.symbol) return # 计算残差的标准差上下轨 mean = np.mean(resid) up = mean + 1.5 * np.std(resid) down = mean - 1.5 * np.std(resid) # 计算新残差 resid_new = close_01[-1] - beta * close_02[-1] - c # 获取rb1801的多空仓位 position_01_long = api.getSymbolPosition(symbol=api.tickersCode[0], positionSide=EPositionSide.LONG) position_01_short = api.getSymbolPosition(symbol=api.tickersCode[0], positionSide=EPositionSide.SHORT) if not position_01_long and not position_01_short: if resid_new > up: api.targetPosition(symbol=api.tickersCode[0], qty=1, positionSide=EPositionSide.SHORT) LOG.INFO(\"Open short at market price:%s\", api.tickersCode[0]) api.targetPosition(symbol=api.tickersCode[1], qty=1, positionSide=EPositionSide.LONG) LOG.INFO(\"Open long at market price:%s\", api.tickersCode[1]) if resid_new = down: api.targetPosition(symbol=api.tickersCode[0], qty=0, positionSide=EPositionSide.SHORT) api.targetPosition(symbol=api.tickersCode[1], qty=0, positionSide=EPositionSide.LONG) LOG.INFO(\"Clear all positions\") # 突破上轨开多 if resid_new > up: api.targetPosition(symbol=api.tickersCode[0], qty=1, positionSide=EPositionSide.SHORT) LOG.INFO(\"Open short at market price:%s\", api.tickersCode[0]) api.targetPosition(symbol=api.tickersCode[1], qty=1, positionSide=EPositionSide.LONG) LOG.INFO(\"Open long at market price:%s\", api.tickersCode[1]) def onTerminate(api,exitInfo): print(\"Finished test\") # 协整检验的函数 def cointegration_test(series01, series02): urt_rb1801 = ts.adfuller(np.array(series01), 1)[1] urt_rb1805 = ts.adfuller(np.array(series02), 1)[1] # 同时平稳或不平稳则差分再次检验 if (urt_rb1801 > 0.1 and urt_rb1805 > 0.1) or (urt_rb1801 0.1: result = 0.0 else: result = 1.0 return beta, c, resid, result else: result = 0.0 return 0.0, 0.0, 0.0, result else: result = 0.0 return 0.0, 0.0, 0.0, result dualTrust-日内交易（期货） #!/usr/bin/env python # -*- coding: utf-8 -*- from __future__ import print_function, absolute_import, unicode_literals, division import numpy as np import datetime from etasdk import * import talib import heapq import csv import pandas as pd from collections import deque, OrderedDict import sys reload(sys) sys.setdefaultencoding(\"utf-8\") \"\"\" 期货日内交易 Dual-Trust策略概述： ================== 在Dual Thrust 交易系统中，对于震荡区间的定义非常关键，这也是该交易系统的核心。Dual Thrust在Range 的设置上，引入前N 日的四个价位，Range = Max(HH-LC,HC-LL)来描述震荡区间的大小。其中HH 是N 日High 的最高价，LC 是N 日Close 的最低价，HC 是N 日Close 的最高价，LL 是N 日Low 的最低价。这种方法使得一 定时期内的Range 相对稳定，可以适用于日间的趋势跟踪。Dual Thrust 对于多头和空头的触发条件，考虑了非 对称的幅度，做多和做空参考的Range可以选择不同的周期数，也可以通过参数K1 和K2 来确定。 第一步：计算相关参数，得到上轨Buy_line 和下轨Sell_line： 1、N 日High 的最高价HH, N 日Close 的最低价LC; 2、N 日Close 的最高价HC，N 日Low 的最低价LL; 3、Range = Max(HH-LC,HC-LL)； 4、BuyLine = Open + K1*Range； 5、SellLine = Open + K2*Range； 第二步：交易逻辑 1、当价格向上突破上轨时，如果当时持有空仓，则先平仓，再开多仓；如果没有仓位，则直接开多仓； 2、当价格向下突破下轨时，如果当时持有多仓，则先平仓，再开空仓；如果没有仓位，则直接开空仓； 第三步：止损 1、初始止损 2、入场后跟踪止损 3、出现反向信号止损开反向仓位 4、在收盘前1分钟平仓（14:58） 5、每日最多交易次数2次，多空各一次 回测数据为:ruZ0.CF主力合约的的1min数据 回测时间为:2018-10-8 到2018-10-18 \"\"\" def onInitialize(api): # 设置响应模式 api.setGroupMode(5000, False) api.focused_contracts = \"ruZ0.CF\" api.threshold = 0.015 api.percent = 0.035 api.k = 0.65 api.focused_prd = str(api.focused_contracts.replace(\"Z0.CF\", \".PRD\")) api.setRequireData(instsets=api.focused_prd, symbols=api.focused_contracts, fields=[], bars=[(ETimeSpan.DAY_1, 10), (ETimeSpan.MIN_1, 130)]) # 初始资金和数据测试 account = api.getAccount(symbol=api.focused_contracts, market=MARKET_CHINAFUTURE) api.capital = account.cashAvailable # 账户初始资金 def onBeforeMarketOpen(api, tradeDate): # print(tradeDate) api.trading_day = tradeDate api.bars_since_today = 0 api.lots = 1 api.can_trade = False api.long_can_trade = True api.short_can_trade = True api.code = api.getContinuousSymbol(api.focused_contracts, tradeDate) api.history_range, normalize_tr, last_close = get_history_range(api, api.code) # 订阅合约 if normalize_tr > api.threshold: api.setFocusSymbols(api.code) api.can_trade = True multiply = get_multiply(api, api.focused_contracts) api.lots = int(1000000 / (last_close * multiply)) # print(\"api.can_trade:\", api.can_trade) def onBar(api, bar): if api.can_trade: time_now = datetime.datetime.fromtimestamp(api.timeNow() / 1000) api.bars_since_today += 1 bars = api.getBarsHistory(symbol=bar.symbol, timeSpan=ETimeSpan.MIN_1, count=api.bars_since_today, priceMode=EPriceMode.REAL, fields=None, df=True) # print(\"time_now:\", time_now) today_open = bars['open'].values[0] buy_line, sell_line = get_buy_and_sell_lines(today_open=today_open, history_range=api.history_range, k1=api.k, k2=api.k) position_side = get_position_side(api, bar.symbol) if position_side buy_line and api.long_can_trade: api.targetPosition(symbol=bar.symbol, qty=0, positionSide=EPositionSide.SHORT, remark=\"Reverse!\") api.targetPosition(symbol=bar.symbol, qty=api.lots, positionSide=EPositionSide.LONG, remark=\"Entry LONG!\") api.long_can_trade = False if position_side >= 0 and bar.low 0: symbol_position = api.getSymbolPosition(symbol=bar.symbol, positionSide=EPositionSide.LONG) if bar.low = symbol_position.posLow * (1 + api.percent): api.targetPosition(symbol=bar.symbol, qty=0, positionSide=EPositionSide.SHORT, remark=\"Short Liquid!\") if time_now.hour == 14 and time_now.minute == 59: api.targetPosition(symbol=bar.symbol, qty=0, positionSide=EPositionSide.SHORT, remark=\"Closing the market, Exit Short!\") api.targetPosition(symbol=bar.symbol, qty=0, positionSide=EPositionSide.LONG, remark=\"Closing the market, Exit LONG!\") def onTerminate(api, exit_info): print(\"Finished test\") def get_history_range(api, symbol, look_back=5): \"\"\" 每次开盘之前进行判断： 获取过去N个交易日的最高价HH，最低价LL，最高收盘价HC，最低收盘价 \"\"\" str_fields = ['tradeDate', 'open', 'high', 'low', 'close'] str_index = 'tradeDate' bars = api.getBarsHistory(symbol=symbol, timeSpan=ETimeSpan.DAY_1, skipSuspended=1, count=look_back, df=True, priceMode=EPriceMode.REAL, fields=str_fields).set_index(str_index) if len(bars) "},"data7.html":{"url":"data7.html","title":"平台数据","keywords":"","body":"平台数据 优品量化目前支持上交所、深交所以及四大期货交易所的实时行情数据和历史行情数据。 还提供了股票财务、指数、行业板块、资金等金融数据。 市场与代码约定 股票 代号 交易所名称 举例 CS 上海A股（SH） 600000.CS(浦发银行) CS 深圳A股（SZ） 000001.CS(中国平安) 期货 代号 交易所名称 举例 CF 上海期货交易所（SHFE） cu1801.CF(沪铜1801) CF 大连商品交易所（DCE） jd1801.CF（鸡蛋1801） CF 郑州商品交易所（ZCE） SR1801.CF(白糖1801） CF 中国金融交易所（CFFEX） IF1801.CF（IF1801 沪深300） CF 上海国际能源交易中心（INE） sc1809.CF(原油1809) 特殊集合约定 市场&板块集合 市场集合 说明 CS.SET 沪深A股全部 CF.SET 期货全部（含主力合约） UPPLA.SET 优品行业板块集合 SW1PLA.SET 申万一级行业板块集合 SW2PLA.SET 申万二级行业板块集合 期货商品集合 商品集合只包含标准合约，不包含非标准合约如主力合约次主力合约等 代号 交易所名称 商品集合 集合名称 CF SHFE cu.PRD 沪铜 CF SHFE al.PRD 沪铝 CF SHFE zn.PRD 沪锌 CF SHFE pb.PRD 沪铅 CF SHFE ru.PRD 橡胶 CF SHFE fu.PRD 燃油 CF SHFE rb.PRD 螺纹 CF SHFE wr.PRD 线材 CF SHFE au.PRD 黄金 CF SHFE ag.PRD 白银 CF SHFE bu.PRD 沥青 CF SHFE hc.PRD 热卷 CF SHFE ni.PRD 沪镍 CF SHFE sn.PRD 沪锡 CF INE sc.PRD 原油 CF DCE a.PRD 豆一 CF DCE b.PRD 豆二 CF DCE c.PRD 玉米 CF DCE m.PRD 豆粕 CF DCE y.PRD 豆油 CF DCE p.PRD 棕榈油 CF DCE l.PRD 塑料 CF DCE v.PRD PVC CF DCE j.PRD 焦炭 CF DCE jm.PRD 焦煤 CF DCE i.PRD 铁矿石 CF DCE jd.PRD 鸡蛋 CF DCE fb.PRD 纤维板 CF DCE bb.PRD 胶合板 CF DCE pp.PRD PP CF DCE cs.PRD 淀粉 CF ZCE PM.PRD 普麦 CF ZCE WH.PRD 强麦 CF ZCE SR.PRD 白糖 CF ZCE CF.PRD 棉花 CF ZCE TA.PRD PTA CF ZCE OI.PRD 菜油 CF ZCE RI.PRD 早籼稻 CF ZCE MA.PRD 甲醇 CF ZCE FG.PRD 玻璃 CF ZCE RS.PRD 菜籽 CF ZCE RM.PRD 菜粕 CF ZCE ZC.PRD 动力煤 CF ZCE JR.PRD 粳稻 CF ZCE LR.PRD 晚籼稻 CF ZCE SF.PRD 硅铁 CF ZCE SM.PRD 锰硅 CF ZCE AP.PRD 苹果 CF ZCE CY.PRD 棉纱 CF CFFEX IF.PRD 沪深300 CF CFFEX IC.PRD 中证500 CF CFFEX IH.PRD 上证50 CF CFFEX T.PRD 十年期国债 CF CFFEX TF.PRD 五年期国债 行情数据 优品量化目前支持上交所、深交所以及五大期货交易所的实时行情数据和历史行情数据，包含Tick行情和Bar行情。 Tick-Tick数据 属性 类型 说明 symbol str 标的代码。 bid double 买一价。 ask double 卖一价。 bidVol double 买一量。（单位为实际证券股数） askVol double 卖一量。 last double 最新成交价。 lastVolume double 最新成交量。 lastTurnover double 最新成交额。 totalVolume double 交易日总成交量。 totalTurnover double 交易日总成交额。 high double 交易日最高价。 low double 交易日最低价。 open double 交易日开盘价。 close double 交易日收盘价。 tradeDate long 交易日-年月日，格式为YYYYMMDD timeExch long 交易所的实时时间戳-年月日时分秒 (ms)， timeStr str 交易时间，格式为YYYYMMDD-hhmmss-xxx bids vector 五档买价，包括数量和价格，qtyprice{\"quantity\":qty,\"price\":price}。 asks vector 五档卖价，包括数量和价格。 ceil double 涨停价。 ceil double 跌停价。 position double 持仓量(期货)。 preClose double 昨日收盘价。 preSettle double 昨日结算价。 Bar-Bar数据 属性 类型 说明 symbol str 标的代码。 tradeDate long 交易日-年月日，格式为YYYYMMDD timeStop long bar对应的截止时间戳 (ms) timeStr str 交易时间，格式为YYYYMMDD-hhmmss-xxx timeSpan long K线的时间频率。60-1分钟；300-5分钟；900-15分钟；1800-30分钟；3600-60分钟；86400-1日。 high double 交易日最高价。 low double 交易日最低价。 open double 交易日开盘价。 close double 交易日收盘价。 lastVolume double 最新成交量。 lastTurnover double 最新成交额。 totalVolume double 交易日总成交量。 totalTurnover double 交易日总成交额。 preClose double 昨日收盘价。 Bar行情的频率类型 enum ETimeSpan { MIN_1 , //1分钟K线 MIN_5 , //5分钟K线 MIN_15 , //15分钟K线 MIN_30, //30分钟K线 MIN_60, //60分钟K线 DAY_1, //日K线 }; 期货主力合约 主力合约品种代号后加上Z0；次主力合约品种代号后加上Z1。 商品期货和国债主力合约定义如下： （1）连续三天日持仓量最大，则切换该合约为主力合约 （2）品种上市第一天，主力合约为交割日最近的合约 （3）若当前主力合约到交割月份前一个月的月末持仓量仍为最大，则强制切换成持仓量次之的合约为主力合约，防止主力合约进入交割月 （4）向前切换不回退 （5）每日收盘结算后计算 股指期货主力合约定义如下：主力合约是在最后交易日前一交易日切换，当月合约和下月合约是在最后交易日后一交易日切换。如4月17是最后交易日，主力合约在16号开盘前就已切换；当月合约和下月合约是在4月18号开盘前完成合约切换。 以豆油（Y）为例，主力表示为YZ0，次主力表示为YZ1。判断合约的方法：以前三天持仓量最高且持续递增为主力合约，次之为次主力合约。次主力合约的日期必须大于主力合约。 各品种主力/次主力合约表： 代号 交易所名称 主力合约 次主力合约 合约名称 CF SHFE cuZ0.CF cuZ1.CF 沪铜 CF SHFE alZ0.CF alZ1.CF 沪铝 CF SHFE znZ0.CF znZ1.CF 沪锌 CF SHFE pbZ0.CF pbZ1.CF 沪铅 CF SHFE ruZ0.CF ruZ1.CF 橡胶 CF SHFE fuZ0.CF fuZ1.CF 燃油 CF SHFE rbZ0.CF rbZ1.CF 螺纹 CF SHFE wrZ0.CF wrZ1.CF 线材 CF SHFE auZ0.CF auZ1.CF 黄金 CF SHFE agZ0.CF agZ1.CF 白银 CF SHFE buZ0.CF buZ1.CF 沥青 CF SHFE hcZ0.CF hcZ1.CF 热卷 CF SHFE niZ0.CF niZ1.CF 沪镍 CF SHFE snZ0.CF snZ1.CF 沪锡 CF INE scZ0.CF scZ1.CF 原油 CF DCE aZ0.CF aZ1.CF 豆一 CF DCE bZ0.CF bZ1.CF 豆二 CF DCE cZ0.CF cZ1.CF 玉米 CF DCE mZ0.CF mZ1.CF 豆粕 CF DCE yZ0.CF yZ1.CF 豆油 CF DCE pZ0.CF pZ1.CF 棕榈油 CF DCE lZ0.CF lZ1.CF 塑料 CF DCE vZ0.CF vZ1.CF PVC CF DCE jZ0.CF jZ1.CF 焦炭 CF DCE jmZ0.CF jmZ1.CF 焦煤 CF DCE iZ0.CF iZ1.CF 铁矿石 CF DCE jdZ0.CF jdZ1.CF 鸡蛋 CF DCE fbZ0.CF fbZ1.CF 纤维板 CF DCE bbZ0.CF bbZ1.CF 胶合板 CF DCE ppZ0.CF ppZ1.CF PP CF DCE csZ0.CF csZ1.CF 淀粉 CF ZCE PMZ0.CF PMZ1.CF 普麦 CF ZCE WHZ0.CF WHZ1.CF 强麦 CF ZCE SRZ0.CF SRZ1.CF 白糖 CF ZCE CFZ0.CF CFZ1.CF 棉花 CF ZCE TAZ0.CF TAZ1.CF PTA CF ZCE OIZ0.CF OIZ1.CF 菜油 CF ZCE RIZ0.CF RIZ1.CF 早籼稻 CF ZCE MAZ0.CF MAZ1.CF 甲醇 CF ZCE FGZ0.CF FGZ1.CF 玻璃 CF ZCE RSZ0.CF RSZ1.CF 菜籽 CF ZCE RMZ0.CF RMZ1.CF 菜粕 CF ZCE ZCZ0.CF ZCZ1.CF 动力煤 CF ZCE JRZ0.CF JRZ1.CF 粳稻 CF ZCE LRZ0.CF LRZ1.CF 晚籼稻 CF ZCE SFZ0.CF SFZ1.CF 硅铁 CF ZCE SMZ0.CF SMZ1.CF 锰硅 CF ZCE APZ0.CF APZ1.CF 苹果 CF ZCE CYZ0.CF CYZ1.CF 棉纱 CF CFFEX IFZ0.CF 沪深300 CF CFFEX ICZ0.CF 中证500 CF CFFEX IHZ0.CF 上证50 CF CFFEX TZ0.CF TZ1.CF 十年期国债 CF CFFEX TFZ0.CF TFZ1.CF 五年期国债 注意： 如果用主力合约下单，平台不负责帮用户做换仓操作，需要用户自己通过策略控制。 期货连续合约 【股指期货】 支持当月连续、下月连续、下季连续、隔季连续合约、分别用品种名称+M0,M1,M3,M6表示，如'IFM0'，'IFM1'，'IFM3'，'IFM6'表示股指期货沪深300当月、下月、下季、隔季连续合约。 举例：如果今天是17年6月29日，则IF类的当月连续为“IF1707”，因为IF1706在6月16日已经交割（每个月的第三个周五），下月连续为“IF1708”，下季连续为“IF1709”，隔季连续为“IF1712”；如果今天是17年7月3日，则IF类的当月连续为“IF1707”，因为IF1707还未到交割日（每个月的第三个周五），下月连续为“IF1708”，下季连续为“IF1709”，隔季连续为“IF1712”。 【国债期货】 支持当季连续、下季连续、隔季连续合约、分别用品种名称+M0,M3,M6表示，如'TM0'，'TM3'，'TM6'表示十年国债期货当季、下季、隔季连续合约。 标的基础信息 refData中保存数据的基础信息 属性 类型 说明 symbol str 标的代码。 marketName str 品种名称。CS-股票；CF-期货；IDX-指数。 exchange str 交易所及自定义类型后缀。SZ-深交所；SH上交所；DCE-大商所；SHFE-上期所；CZCE-郑商所；CFFEX-中金所；PLATE-板块；SET-证券集合。 currency str 币种。 lotSize double 一手标的的数目。 name str 标的名称。 tplus int T+N交易。例如tplus为1时为t+1交易。 marginRate double 保证金比例。 shortSellable bool 是否可卖空。 valuePerUnit double 合约乘数 priceTick double 标的价格浮动最小单位值 exchSymbol str 交易所的原始symbol isStandard bool 是否是交易所的标准合约，比如主力合约 IFZ0.CF 就不是交易所的标准合约 tradeMarket str 该标的对应的交易市场，目前仅有 CS CF listDate int 上市日，无则为0。 lastTradeDate int 最后交易日(退市日)，无则为0。 股票指数代码 目前只提供2011年1月1日至今的指数行情数据以及指数成份股数据 指数代码 指数简称 000001.IDX 上证指数 399001.IDX 深证成指 000300.IDX 沪深300 399005.IDX 中小板指 399006.IDX 创业板指 000010.IDX 上证180 000016.IDX 上证50 000009.IDX 上证380 000132.IDX 上证100 000133.IDX 上证150 399106.IDX 深证综指 399004.IDX 深证100 399007.IDX 深圳300 399008.IDX 中小300 000852.IDX 中证1000 000903.IDX 中证100 000904.IDX 中证200 000905.IDX 中证500 000906.IDX 中证800 股票行业板块代码 目前主要提供优品行业板块代码、申万一级行业板块代码和申万二级行业板块代码。可以通过集合获取对应板块的所有代码，如调用UPPLA.SET则返回的是优品行业板块的所有代码。 优品行业代码 提供优品行业的成分股数据，只支持2014年1月1日至今的数据。 行业代码 行业名称 880001.PLA 农林牧渔 880002.PLA 石油 880003.PLA 煤炭 880004.PLA 其他采掘 880007.PLA 化工原料 880008.PLA 化学制品 880009.PLA 化学纤维 880010.PLA 橡胶塑料 880012.PLA 化工新材料 880013.PLA 钢铁 880014.PLA 有色金属 880015.PLA 金属新材料 880016.PLA 建材 880017.PLA 建筑 880018.PLA 通用机械 880019.PLA 工程机械 880020.PLA 仪器仪表 880021.PLA 电气设备 880022.PLA 金属制品 880023.PLA 电子元器件 880024.PLA 汽车 880025.PLA 通信设备 880026.PLA 电脑设备 880027.PLA 家用电器 880028.PLA 酿酒饮料 880029.PLA 食品加工 880030.PLA 纺织服装 880031.PLA 造纸印刷 880033.PLA 轻工制造 880035.PLA 医药 880039.PLA 医疗器械服务 880041.PLA 电力 880042.PLA 水务 880043.PLA 燃气 880044.PLA 环保工程 880045.PLA 交通运输 880046.PLA 房地产 880047.PLA 银行 880048.PLA 多元金融 880049.PLA 证券 880050.PLA 保险 880051.PLA 零售贸易 880052.PLA 旅游 880053.PLA 酒店餐饮 880056.PLA 通信运营 880057.PLA 网络服务 880058.PLA 软件服务 880059.PLA 文化传媒 880060.PLA 综合 880064.PLA 国防军工 880065.PLA 交运设备 申万一级行业代码 提供申万一级行业,包含2011版和2014版，并可获取申万一级行业指数日线级别行情数据。 行业代码 行业名称 801010.PLA 农林牧渔 801020.PLA 采掘 801030.PLA 化工 801040.PLA 黑色金属 801050.PLA 有色金属 801060.PLA 建筑建材 801070.PLA 机械设备 801080.PLA 电子 801090.PLA 交运设备 801100.PLA 信息设备 801110.PLA 家用电器 801120.PLA 食品饮料 801130.PLA 纺织服装 801140.PLA 轻工制造 801150.PLA 医药生物 801160.PLA 公用事业 801170.PLA 交通运输 801180.PLA 房地产 801190.PLA 金融服务 801200.PLA 商业贸易 801210.PLA 餐饮旅游 801220.PLA 信息服务 801230.PLA 综合 801710.PLA 建筑材料 801720.PLA 建筑装饰 801730.PLA 电气设备 801740.PLA 国防军工 801750.PLA 计算机 801760.PLA 传媒 801770.PLA 通信 801780.PLA 银行 801790.PLA 非银金融 801880.PLA 汽车 801890.PLA 机械设备 申万二级行业代码 提供申万二级行业代码，,包含2011版和2014版 行业代码 行业名称 801011.PLA 林业 801012.PLA 农产品加工 801013.PLA 农业综合 801014.PLA 饲料 801015.PLA 渔业 801016.PLA 种植业 801017.PLA 畜禽养殖 801018.PLA 动物保健 801021.PLA 煤炭开采 801022.PLA 其他采掘 801023.PLA 石油开采 801024.PLA 采掘服务 801031.PLA 化工新材料 801032.PLA 化学纤维 801033.PLA 化学原料 801034.PLA 化学制品 801035.PLA 石油化工 801036.PLA 塑料 801037.PLA 橡胶 801041.PLA 钢铁 801051.PLA 金属非金属新材料 801052.PLA 有色金属冶炼与加工 801053.PLA 黄金 801054.PLA 稀有金属 801055.PLA 工业金属 801061.PLA 建筑材料 801062.PLA 建筑装饰 801071.PLA 电气设备 801072.PLA 通用机械 801073.PLA 仪器仪表 801074.PLA 专用设备 801075.PLA 金属制品 801076.PLA 运输设备 801081.PLA 半导体 801082.PLA 其他电子 801083.PLA 元件 801084.PLA 光学光电子 801085.PLA 电子制造 801091.PLA 非汽车交运设备 801092.PLA 交运设备服务 801093.PLA 汽车零部件 801094.PLA 汽车整车 801101.PLA 计算机设备 801102.PLA 通信设备 801111.PLA 白色家电 801112.PLA 视听器材 801123.PLA 饮料制造 801124.PLA 食品加工制造 801131.PLA 纺织制造 801132.PLA 服装家纺 801141.PLA 包装印刷 801142.PLA 家用轻工 801143.PLA 造纸 801144.PLA 其他轻工制造 801151.PLA 化学制药 801152.PLA 生物制品 801153.PLA 医疗器械 801154.PLA 医药商业 801155.PLA 中药 801156.PLA 医疗服务 801161.PLA 电力 801162.PLA 环保工程及服务 801163.PLA 燃气 801164.PLA 水务 801171.PLA 港口 801172.PLA 公交 801173.PLA 航空运输 801174.PLA 机场 801175.PLA 高速公路 801176.PLA 航运 801177.PLA 铁路运输 801178.PLA 物流 801181.PLA 房地产开发 801182.PLA 园区开发 801191.PLA 多元金融 801192.PLA 银行 801193.PLA 证券 801194.PLA 保险 801201.PLA 零售 801202.PLA 贸易 801203.PLA 一般零售 801204.PLA 专业零售 801205.PLA 商业物业经营 801211.PLA 餐饮 801212.PLA 景点 801213.PLA 酒店 801214.PLA 旅游综合 801215.PLA 其他休闲服务 801221.PLA 传媒 801222.PLA 计算机应用 801223.PLA 通信运营 801224.PLA 网络服务 801231.PLA 综合 801711.PLA 水泥制造 801712.PLA 玻璃制造 801713.PLA 其他建材 801721.PLA 房屋建设 801722.PLA 装修装饰 801723.PLA 基础建设 801724.PLA 专业工程 801725.PLA 园林工程 801731.PLA 电机 801732.PLA 电气自动化设备 801733.PLA 电源设备 801734.PLA 高低压设备 801741.PLA 航天装备 801742.PLA 航空装备 801743.PLA 地面兵装 801744.PLA 船舶制造 801751.PLA 营销传播 801752.PLA 互联网传媒 801761.PLA 文化传媒 801881.PLA 其他交运设备 股票交易指标-日频 交易状态 fields 说明 TRADE_STA 交易状态。交易-True 停牌-False LIST_STA 上市状态。正常上市-1，暂停上市-2，终止上市-3，恢复上市-4，退市整理-5，未上市-6 CUML_EX_FACTOR 累计复权因子 ST_STA 特殊处理状态， ST *ST-True ， 正常-False 基于L2衍生因子-深市 主要统计不同资金规模的委托的成交量和成交金额（只考虑限价单）因子名由三部分组成：因子名后面的两个数字，表示该因子统计的是委托金额位于该区间内的委托，如0_5表示统计的是委托金额在0w~5w的委拖;如果是inf则表示无穷大，即没有上限因子名中间是VOL或AMOUNT，VOL表示统计的是成交量，AMOUNT表示统计的是成交金额因子名前面是BUY、SELL、QUITS，BUY表示统计的是买委托成交（即只要买委托的委托金额位于后面指定的区间则计算），SELL表示统计的是卖委托成交（即只要卖委托的委托金额位于后面指定的区间则计算），QUITS表示统计买&卖委托成交（即需要买卖委托双方的委托金额都位于后面指定的区间才计算） fields 说明 BUY_AMOUNT_0_5 委托金额0w-5w的买委托的成交金额 BUY_AMOUNT_1000_INF 委托金额1000w-∞的买委托的成交金额 BUY_AMOUNT_100_200 委托金额100w-200w的买委托的成交金额 BUY_AMOUNT_10_20 委托金额10w-20w的买委托的成交金额 BUY_AMOUNT_200_500 委托金额200w-500w的买委托的成交金额 BUY_AMOUNT_20_50 委托金额20w-50w的买委托的成交金额 BUY_AMOUNT_500_1000 委托金额500w-1000w的买委托的成交金额 BUY_AMOUNT_50_100 委托金额50w-100w的买委托的成交金额 BUY_AMOUNT_5_10 委托金额5w-10w的买委托的成交金额 BUY_VOL_0_5 委托金额0w-5w的买委托的成交量 BUY_VOL_1000_INF 委托金额1000w-∞的买委托的成交量 BUY_VOL_100_200 委托金额100w-200w的买委托的成交量 BUY_VOL_10_20 委托金额10w-20w的买委托的成交量 BUY_VOL_200_500 委托金额200w-500w的买委托的成交量 BUY_VOL_20_50 委托金额20w-50w的买委托的成交量 BUY_VOL_500_1000 委托金额500w-1000w的买委托的成交量 BUY_VOL_50_100 委托金额50w-100w的买委托的成交量 BUY_VOL_5_10 委托金额5w-10w的买委托的成交量 ORDER_BUY_AMOUNT_0_5Q 0万_0.5万的买委托金额 ORDER_BUY_AMOUNT_1000_INF 100万_∞的买委托金额 ORDER_BUY_AMOUNT_100_200 100万_200万的买委托金额 ORDER_BUY_AMOUNT_10_20 10万_20万的买委托金额 ORDER_BUY_AMOUNT_1_2 1万_2万的买委托金额 ORDER_BUY_AMOUNT_200_500 200万_500万的买委托金额 ORDER_BUY_AMOUNT_20_50 20万_50万的买委托金额 ORDER_BUY_AMOUNT_2_5 2万_5万的买委托金额 ORDER_BUY_AMOUNT_500_1000 500万_1000万的买委托金额 ORDER_BUY_AMOUNT_50_100 50万_100万的买委托金额 ORDER_BUY_AMOUNT_5_10 5万_10万的买委托金额 ORDER_BUY_AMOUNT_5Q_1 0.5万_1万的买委托金额 ORDER_BUY_FRQUENCE_0_5Q 0万_0.5万的买委托金额的频数 ORDER_BUY_FRQUENCE_1000_INF 100万_∞的买委托金额的频数 ORDER_BUY_FRQUENCE_100_200 100万_200万的买委托金额的频数 ORDER_BUY_FRQUENCE_10_20 10万_20万的买委托金额的频数 ORDER_BUY_FRQUENCE_1_2 1万_2万的买委托金额的频数 ORDER_BUY_FRQUENCE_200_500 200万_500万的买委托金额的频数 ORDER_BUY_FRQUENCE_20_50 20万_50万的买委托金额的频数 ORDER_BUY_FRQUENCE_2_5 2万_5万的买委托金额的频数 ORDER_BUY_FRQUENCE_500_1000 500万_1000万的买委托金额的频数 ORDER_BUY_FRQUENCE_50_100 50万_100万的买委托金额的频数 ORDER_BUY_FRQUENCE_5_10 5万_10万的买委托金额的频数 ORDER_BUY_FRQUENCE_5Q_1 0.5万_1万的买委托金额的频数 ORDER_BUY_VOLUME_0_5Q 0万_0.5万的买委托量 ORDER_BUY_VOLUME_1000_INF 100万_∞的买委托量 ORDER_BUY_VOLUME_100_200 100万_200万的买委托量 ORDER_BUY_VOLUME_10_20 10万_20万的买委托量 ORDER_BUY_VOLUME_1_2 1万_2万的买委托量 ORDER_BUY_VOLUME_200_500 200万_500万的买委托量 ORDER_BUY_VOLUME_20_50 20万_50万的买委托量 ORDER_BUY_VOLUME_2_5 2万_5万的买委托量 ORDER_BUY_VOLUME_500_1000 500万_1000万的买委托量 ORDER_BUY_VOLUME_50_100 50万_100万的买委托量 ORDER_BUY_VOLUME_5_10 5万_10万的买委托量 ORDER_BUY_VOLUME_5Q_1 0.5万_1万的买委托量 ORDER_SELL_AMOUNT_0_5Q 0万_0.5万的卖委托金额 ORDER_SELL_AMOUNT_1000_INF 100万_∞的卖委托金额 ORDER_SELL_AMOUNT_100_200 100万_200万的卖委托金额 ORDER_SELL_AMOUNT_10_20 10万_20万的卖委托金额 ORDER_SELL_AMOUNT_1_2 1万_2万的卖委托金额 ORDER_SELL_AMOUNT_200_500 200万_500万的卖委托金额 ORDER_SELL_AMOUNT_20_50 20万_50万的卖委托金额 ORDER_SELL_AMOUNT_2_5 2万_5万的卖委托金额 ORDER_SELL_AMOUNT_500_1000 500万_1000万的卖委托金额 ORDER_SELL_AMOUNT_50_100 50万_100万的卖委托金额 ORDER_SELL_AMOUNT_5_10 5万_10万的卖委托金额 ORDER_SELL_AMOUNT_5Q_1 0.5万_1万的卖委托金额 ORDER_SELL_FRQUENCE_0_5Q 0万_0.5万的卖委托金额的频数 ORDER_SELL_FRQUENCE_1000_INF 100万_∞的卖委托金额的频数 ORDER_SELL_FRQUENCE_100_200 100万_200万的卖委托金额的频数 ORDER_SELL_FRQUENCE_10_20 10万_20万的卖委托金额的频数 ORDER_SELL_FRQUENCE_1_2 1万_2万的卖委托金额的频数 ORDER_SELL_FRQUENCE_200_500 200万_500万的卖委托金额的频数 ORDER_SELL_FRQUENCE_20_50 20万_50万的卖委托金额的频数 ORDER_SELL_FRQUENCE_2_5 2万_5万的卖委托金额的频数 ORDER_SELL_FRQUENCE_500_1000 500万_1000万的卖委托金额的频数 ORDER_SELL_FRQUENCE_50_100 50万_100万的卖委托金额的频数 ORDER_SELL_FRQUENCE_5_10 5万_10万的卖委托金额的频数 ORDER_SELL_FRQUENCE_5Q_1 0.5万_1万的卖委托金额的频数 ORDER_SELL_VOLUME_0_5Q 0万_0.5万的卖委托量 ORDER_SELL_VOLUME_1000_INF 100万_∞的卖委托量 ORDER_SELL_VOLUME_100_200 100万_200万的卖委托量 ORDER_SELL_VOLUME_10_20 10万_20万的卖委托量 ORDER_SELL_VOLUME_1_2 1万_2万的卖委托量 ORDER_SELL_VOLUME_200_500 200万_500万的卖委托量 ORDER_SELL_VOLUME_20_50 20万_50万的卖委托量 ORDER_SELL_VOLUME_2_5 2万_5万的卖委托量 ORDER_SELL_VOLUME_500_1000 500万_1000万的卖委托量 ORDER_SELL_VOLUME_50_100 50万_100万的卖委托量 ORDER_SELL_VOLUME_5_10 5万_10万的卖委托量 ORDER_SELL_VOLUME_5Q_1 0.5万_1万的卖委托量 QUITS_AMOUNT_0_5 委托金额0w-5w的买委托&委托金额0w~5w的卖委托成交的成交金额 QUITS_AMOUNT_1000_INF 委托金额1000w-∞的买委托&委托金额1000w-∞的卖委托成交的成交金额 QUITS_AMOUNT_100_200 委托金额100w-200w的买委托&委托金额100w-200w的卖委托成交的成交金额 QUITS_AMOUNT_10_20 委托金额10w-20w的买委托&委托金额10w-20w的卖委托成交的成交金额 QUITS_AMOUNT_200_500 委托金额200w-500w的买委托&委托金额200w-500w的卖委托成交的成交金额 QUITS_AMOUNT_20_50 委托金额20w-50w的买委托&委托金额20w-50w的卖委托成交的成交金额 QUITS_AMOUNT_500_1000 委托金额500w-1000w的买委托&委托金额500w-1000w的卖委托成交的成交金额 QUITS_AMOUNT_50_100 委托金额50w-100w的买委托&委托金额50w-100w的卖委托成交的成交金额 QUITS_AMOUNT_5_10 委托金额5w-10w的买委托&委托金额5w-10w的卖委托成交的成交金额 QUITS_VOL_0_5 委托金额0w-5w的买委托&委托金额0w~5w的卖委托成交的成交量 QUITS_VOL_1000_INF 委托金额1000w-∞的买委托&委托金额1000w-∞的卖委托成交的成交量 QUITS_VOL_100_200 委托金额100w-200w的买委托&委托金额100w-200w的卖委托成交的成交量 QUITS_VOL_10_20 委托金额10w-20w的买委托&委托金额10w-20w的卖委托成交的成交量 QUITS_VOL_200_500 委托金额200w-500w的买委托&委托金额200w-500w的卖委托成交的成交量 QUITS_VOL_20_50 委托金额20w-50w的买委托&委托金额20w-50w的卖委托成交的成交量 QUITS_VOL_500_1000 委托金额500w-1000w的买委托&委托金额500w-1000w的卖委托成交的成交量 QUITS_VOL_50_100 委托金额50w-100w的买委托&委托金额50w-100w的卖委托成交的成交量 QUITS_VOL_5_10 委托金额5w-10w的买委托&委托金额5w-10w的卖委托成交的成交量 SELL_AMOUNT_0_5 委托金额0w-5w的卖委托的成交金额 SELL_AMOUNT_1000_INF 委托金额1000w-∞的卖委托的成交金额 SELL_AMOUNT_100_200 委托金额100w-200w的卖委托的成交金额 SELL_AMOUNT_10_20 委托金额10w-20w的卖委托的成交金额 SELL_AMOUNT_200_500 委托金额200w-500w的卖委托的成交金额 SELL_AMOUNT_20_50 委托金额20w-50w的卖委托的成交金额 SELL_AMOUNT_500_1000 委托金额500w-1000w的卖委托的成交金额 SELL_AMOUNT_50_100 委托金额50w-100w的卖委托的成交金额 SELL_AMOUNT_5_10 委托金额5w-10w的卖委托的成交金额 SELL_VOL_0_5 委托金额0w-5w的卖委托的成交量 SELL_VOL_1000_INF 委托金额1000w-∞的卖委托的成交量 SELL_VOL_100_200 委托金额100w-200w的卖委托的成交量 SELL_VOL_10_20 委托金额10w-20w的卖委托的成交量 SELL_VOL_200_500 委托金额200w-500w的卖委托的成交量 SELL_VOL_20_50 委托金额20w-50w的卖委托的成交量 SELL_VOL_500_1000 委托金额500w-1000w的卖委托的成交量 SELL_VOL_50_100 委托金额50w-100w的卖委托的成交量 SELL_VOL_5_10 委托金额5w-10w的卖委托的成交量 TRADE_AMOUNT_0_5Q 0万_0.5万的成交金额 TRADE_AMOUNT_1000_INF 100万_∞的成交金额 TRADE_AMOUNT_100_200 100万_200万的成交金额 TRADE_AMOUNT_10_20 10万_20万的成交金额 TRADE_AMOUNT_1_2 1万_2万的成交金额 TRADE_AMOUNT_200_500 200万_500万的成交金额 TRADE_AMOUNT_20_50 20万_50万的成交金额 TRADE_AMOUNT_2_5 2万_5万的成交金额 TRADE_AMOUNT_500_1000 500万_1000万的成交金额 TRADE_AMOUNT_50_100 50万_100万的成交金额 TRADE_AMOUNT_5_10 5万_10万的成交金额 TRADE_AMOUNT_5Q_1 0.5万_1万的成交金额 TRADE_FRQUENCE_0_5Q 0万_0.5万的成交金额的频数 TRADE_FRQUENCE_1000_INF 100万_∞的成交金额的频数 TRADE_FRQUENCE_100_200 100万_200万的成交金额的频数 TRADE_FRQUENCE_10_20 10万_20万的成交金额的频数 TRADE_FRQUENCE_1_2 1万_2万的成交金额的频数 TRADE_FRQUENCE_200_500 200万_500万的成交金额的频数 TRADE_FRQUENCE_20_50 20万_50万的成交金额的频数 TRADE_FRQUENCE_2_5 2万_5万的成交金额的频数 TRADE_FRQUENCE_500_1000 500万_1000万的成交金额的频数 TRADE_FRQUENCE_50_100 50万_100万的成交金额的频数 TRADE_FRQUENCE_5_10 5万_10万的成交金额的频数 TRADE_FRQUENCE_5Q_1 0.5万_1万的成交金额的频数 TRADE_VOLUME_0_5Q 0万_0.5万的成交量 TRADE_VOLUME_1000_INF 100万_∞的成交量 TRADE_VOLUME_100_200 100万_200万的成交量 TRADE_VOLUME_10_20 10万_20万的成交量 TRADE_VOLUME_1_2 1万_2万的成交量 TRADE_VOLUME_200_500 200万_500万的成交量 TRADE_VOLUME_20_50 20万_50万的成交量 TRADE_VOLUME_2_5 2万_5万的成交量 TRADE_VOLUME_500_1000 500万_1000万的成交量 TRADE_VOLUME_50_100 50万_100万的成交量 TRADE_VOLUME_5_10 5万_10万的成交量 TRADE_VOLUME_5Q_1 0.5万_1万的成交量 市值数据 主要展示策略常用因子 fields 说明 PCF 市现率 PS 市销率 PB 市净率 PE 市盈率 VIBR_RANGE 振幅 TURNOVER_RATE 换手率 TOT_SHARE 总股本 FLOAT_SHARE 流通股合计 CIRC_CAP 流通市值 MKT_CAP 总市值 CASH_BT 每股股利(税前) CASH_AT 每股股利(税后) BONUS_SHR 每股红股 HLD_NUM_CHG_RATIO 股东总户数增长率 STATE_REST 限售股份(国家持股) STATE_LEG_REST 限售股份(国家法人持股) MAN_RES 限售股份(高管持股) DOM_REST 限售股份(其它内资持股合计) DOM_NATU_REST 限售股份(其它内资_境内自然人持股) DOM_LEG_REST 限售股份(其它内资_境内法人持股) FORE_REST 限售股份(外资持股合计) FORE_NATU_RES 限售股份(外资_境外自然人持股) FORE_LEG_RES 限售股份(外资_境外法人持股) 股票财务数据-季频 资产负债表 fields 说明 CASH_EQUIV 货币资金及现金或存放中央银行款项 SETT_PROVI 结算备付金(金融类) LEND_CAPITAL 拆出资金(金融类) FIN_ASSETS 以公允价值计量且其变动计入当期损益的金融资产 NOTES_REC 应收票据 DIVIDEND_REC 应收股利 INTEREST_REC 应收利息 ACCOUNTS_REC 应收账款 OTHER_REC 其他应收款 PREPAYMENT 预付款项 INVENTORIES 存货 NCA_IN_1Y 一年内到期的非流动资产 OTHER_CA 其他流动资产 SPECIAL_CA 流动资产特殊项目 TOT_CA 流动资产合计 LOAN_AND_ADVANCE 发放贷款和垫款(金融类) FA_AVAIL_FOR_SALE 可供出售金融资产 HTM_INVEST 持有至到期投资 INVEST_ESTATE 投资性房地产 LT_EQUITY_INVEST 长期股权投资 LT_REC_ACCOUNT 长期应收款 FIXED_ASSETS 固定资产 CONST_MATERIALS 工程物资 CONST_IN_PROCESS 在建工程 FIXED_ASS_DISP 固定资产清理 BIO_ASSETS 生产性生物资产 OIL_GAS_ASSETS 油气资产 INTAN_ASSETS 无形资产 DEV_EXPENDITURE 开发支出 GOOD_WILL 商誉 LT_PREPAID_COST 长期待摊费用 DEFER_TAX_ASSETS 递延所得税资产 OTHER_NCA 其他非流动资产 SPECIAL_NCA 非流动资产特殊项目 TOT_NCA 非流动资产合计 TOT_ASSETS 资产总计 ST_BORR 短期借款 CB_BORR 向中央银行借款(金融类) DEPOS 同业及其他金融机构存放款项(金融类) NOTES_PAYABLE 应付票据 ACCOUNTS_PAYABLE 应付账款 ADVANCE_PECEIPTS 预收款项 SALARIES_PAYABLE 应付职工薪酬 DIVIDEND_PAYABLE 应付股利 TAXS_PAYABLE 应交税费 INTEREST_PAYABLE 应付利息 OTHER_PAYABLE 其他应付款 NCL_IN_1Y 一年内到期的非流动负债 OTHER_CL 其他流动负债 SPECIAL_CL 流动负债特殊项目 TOT_CL 流动负债合计 LT_BORR 长期借款 BOND_PAYABLE 应付债券 LT_PAYABLE 长期应付款 SP_PAYABLE 专项应付款 ESTIMATE_LIAB 预计负债 DEFER_TAX_LIAB 递延所得税负债 OTHER_NCL 其他非流动负债 SPECIAL_NCL 非流动负债特殊项目 TOT_NCL 非流动负债合计 SPECIAL_LIAB 负债特殊项目 TOT_LIAB 负债合计 PAIDIN_CAPITAL 实收资本(或股本) CAPITAL_RESER 资本公积 TREASURY_SHARE 减：库存股 SP_RESER 专项储备 SURPLUS_RESER 盈余公积 RETAINED_PROFIT 未分配利润 ORDIN_RISK_RESER 一般风险准备 FOREIGN_DIFF 外币报表折算差额 TE_ATTRP 归属母公司权益合计 MINORITY_INTERESTS 少数股东权益 TOT_OWNER_EQUITY 所有者权益合计 TOT_LIAB_EQUITY 负债和所有者权益合计 利润表 fields 说明 TOT_OP_REVENUE 营业总收入(非金融类) REVENUE 营业收入 INT_NET_INCOME 利息净收入(金融类) INT_INCOME 其中:利息收入(金融类) INT_EXP 其中:利息支出(金融类) COMMIS_NET_INCOME 手续费及佣金净收入(金融类) COMMIS_INCOME 其中:手续费及佣金收入(金融类) COMMIS_EXP 其中:手续费及佣金支出(金融类) TOT_OP_COST 营业总成本(非金融类) TOT_COST 营业成本(非金融类) OP_TAX_SURCHG 营业税金及附加 SELL_EXP 销售费用(非金融类) ADMIN_EXP 管理费用(非金融类) FIN_EXP 财务费用(非金融类) ASSETS_IMPAIR_LOSS 资产减值损失 FVALUE_CHG_INCOME 公允价值变动净收益 INVEST_INCOME 投资收益 INVEST_INCOME_ASSOCIATES 其中:对联营企业和合营企业的投资收益 CHARGE_INCOME 汇兑收益 OPERATE_PROFIT 营业利润 NOPERATE_INCOME 加：营业外收入 NOPERATE_EXP 减：营业外支出 NCA_DISP_LOSS 其中：非流动资产处置净损失 TOT_PROFIT 利润总额 INCOME_TAX 减：所得税费用 NET_PROFIT 净利润 NET_PROFIT_ATTRP 归属于母公司所有者的净利润 MINORITY_PROFIT 少数股东损益 BASIC_EPS (一)基本每股收益 DILUTED_EPS (二)稀释每股收益 OTHER_COMPR_INCOME 其他综合收益 OTHER_COMPR_INCOME_ATTRP 归属于母公司所有者的其他综合收益的税后净额 TOT_COMPR_INCOME 综合收益总额 TOT_COMPR_INCOME_ATTRP 归属于母公司所有者的综合收益总额 TOT_COMPR_INCOME_ATTRMS 归属于少数股东的综合收益总额 现金流量表 fields 说明 CASH_RECV_FROM_GS_SERV 销售商品、提供劳务收到的现金(非金融类) NET_DEPOSIT_INCREASE 客户存款和同业存放款项净增加额(金融类) NINC_BORR_OTH_FI 向其他金融机构拆入资金净增加额(金融类) CASH_RECV_FROM_INT_AND_COMMIS 收取利息、手续费及佣金的现金(金融类) CASH_RECV_FROM_OTHER_OP 收到其他与经营活动有关的现金 SUBTOT_OPERATE_CASH_INFLOW 经营活动现金流入小计 CASH_PAID_FOR_GOODS_AND_SERV 购买商品、接受劳务支付的现金(非金融类) STAFF_PAID 支付给职工以及为职工支付的现金 TAX_PAYMENTS 支付的各项税费 CASH_PAID_FOR_INT_AND_COMMIS 支付利息、手续费及佣金的现金(金融类) CASH_PAID_FOR_OTHER_OP 支付其他与经营活动有关的现金 SUBTOT_OPERATE_CASH_OUTFLOW 经营活动现金流出小计 OPERATE_NET_CASH_FLOW 经营活动现金流量净额 CASH_RECV_FROM_INVEST 收回投资收到的现金 CASH_RECV_FROM_RETURN_ON_INVEST 取得投资收益收到的现金 NET_CASH_RECV_FROM_DEAL_ASSETS 处置固定资产、无形资产和其他长期资产收回的现金净额 NET_CASH_RECV_FROM_DEAL_SUBCOM 处置子公司及其他营业单位收到的现金净额 CASH_RECV_FROM_OTHER_INVEST 收到其他与投资活动有关的现金 SUBTOT_INVEST_CASH_INFLOW 投资活动现金流入小计 CASH_PAID_FOR_ACQU_ASSETS 购建固定资产、无形资产和其他长期资产支付的现金 CASH_PAID_FOR_INVEST 投资支付的现金 NET_CASH_RECV_FROM_SUBCOM 取得子公司及其他营业单位支付的现金净额 CASH_PAID_FOR_OTHER_INVEST 支付其他与投资活动有关的现金 SUBTOT_INVEST_CASH_OUTFLOW 投资活动现金流出小计 INVEST_NET_CASH_FLOW 投资活动现金流量净额 CASH_FROM_INVEST 吸收投资收到的现金 CASH_FROM_MINO_S_SUB 其中：子公司吸收少数股东投资收到的现金 CASH_FROM_BONDS_ISSUE 发行债券收到的现金 CASH_FROM_BORR 取得借款收到的现金 CASH_RECV_FROM_OTHER_FIN 收到其他与筹资活动有关的现金 SUBTOT_FIN_CASH_INFLOW 筹资活动现金流入小计 CASH_PAID_FOR_DEBTS 偿还债务支付的现金 CASH_PAID_FOR_DIST_INT_AND_COMMIS 分配股利、利润或偿付利息支付的现金 CASH_PAID_FOR_OTHER_FIN 支付其他与筹资活动有关的现金 SUBTOT_FIN_CASH_OUTFLOW 筹资活动现金流出小计 FIN_NET_CASH_FLOW 筹资活动现金流量净额 EXCHNG_RATE_CHG_EFFECT 汇率变动对现金及现金等价物的影响 CASH_EQUIVALENT_INCREASE 现金及等价物净增加额 CASH_EQUIVALENTS_AT_BEGIN 加：期初现金及现金等价物余额 CASH_EQUIVALENTS_AT_END 期末现金及现金等价物余额 表格型数据 获取表格型数据方式为：get_table_field(symbol, field, start_date, end_date, count, columns) 期货成交量 field: FUT_TRADE_RANK columns 说明 rank 排名 volumeDiff 比上交易日增减/变化 volume 成交量/持买单量/持卖单量 name 期货公司会员简称 期货持卖单量 field: FUT_SHORT_RANK columns 说明 rank 排名 volumeDiff 比上交易日增减/变化 volume 成交量/持买单量/持卖单量 name 期货公司会员简称 期货持买单量 field: FUT_LONG_RANK columns 说明 rank 排名 volumeDiff 比上交易日增减/变化 volume 成交量/持买单量/持卖单量 name 期货公司会员简称 申万一级行业指数日K行情数据 field: SW_MKT columns 说明 close 收盘价 high 最高价 low 最低价 open 开盘价 preClose 昨收价 tradeDate 交易日期 turnover 成交额 volume 成交量 "},"question8.html":{"url":"question8.html","title":"常见问题","keywords":"","body":"常见问题 关于优品量化 什么是量化投资？ 量化投资指的是通过数量化的方式及计算机程序将投资者的投资思想进行变量化，形成一套可以被计算机识别操作思路，利用历史数据加以分析和验证，并由程序来进行交易指令的执行。 量化投资具体内容是什么？ 量化投资包含甚广，具体内容和手段有以下： 阿尔法策略：建仓具有超额收益的股票，设定风险敞口以相应的股指对冲，获取超额收益，避免系统风险。 对冲套利：ETF折溢价套利、股指期货期现套利、期货跨期套利、股票的配对交易、期货的跨期套利、跨品种套利、跨市场套利。 风险管理：净值波动管理、仓位管理、资产配置管理、组合权重管理。 算法交易：为了降低冲击成本的算法自动交易。 高频交易：针对盘口机会以极高的频率交易商品。 CTA：基于综合交易平台的趋势程序化；基于盘口数据报单的程序化交易。 量化投资的优势是？ 纪律性：严格执行投资策略，克服人性的贪婪、恐惧。 准确性：准确客观评价交易机会，克服主观情绪偏差，从而盈利。 系统性：多层次的量化模型、多角度的观察及海量数据的处理。 分散化：在控制风险的条件下，量化投资可以充当分散化投资的工具。 及时性：及时快速地跟踪市场变化，不断发现能够提供超额收益的新的统计模型，寻找新的交易机会。 什么是优品量化平台？ 优品量化是优品财富旗下的一款在线量化交易平台，专注于为专业人士及量化投资爱好者提供的专业、可靠、高效的服务。优品量化平台是最专业的多元资产量化交易平台，支持股票、期货多账户多品种的交易。优品量化以海量金融数据为基础，覆盖量化交易完整的生命周期，提供策略研发、策略回测、模拟交易和实盘交易等功能，为您打造一个专属的策略平台。 优品量化提供哪些服务？ 优品量化作为最专业的多元资产量化交易平台，为您提供了如下服务： （1）海量的特色数据和优质的金融大数据 免费提供股票、期货等金融数据，通过专业团队对数据进行深度加工处理，保证数据的精准可靠，为策略运行提供最真实可靠的数据支持。 （2）策略组合功能 零门槛提供python及C++策略编写语言，多策略进行组合，分散风险、降低回撤、增加收益。基于历史行情数据对策略进行回测，一键输出全面的评估结果。 （3）高效的策略回测和模拟交易 接入高频实时行情，一键下单，秒级成交。全面支持股票、期货等多账户多品种的模拟交易，为多类型的策略提供验证支持。 （4）多账户管理 在多用户、多策略、仓位管理等核心逻辑的驱动下，进行策略回测、调试和优化后输出评价报告，产生交易信号，实盘跟踪，进行实时风控。 支持哪些交易品种？ 优品量化当前支持股票和期货的交易，未来将会提供更多品种的交易服务。 可以做套利策略吗？ 可以。优品量化平台的一个策略可同时支持多个市场的代码交易，支持套利策略。 优品量化适用群体？ 专业的投资者和机构用户。 策略问题 有现成策略提供吗？是否收费？ 平台提供期货和股票从入门到专业进阶多类量化策略示例，是免费的。 策略归谁所有？是否安全？ 作为策略的开发者，策略是您最大的财富，您的所有策略、研究内容的知识产权都归您自己所有。 您策略的编写、运行和存储都是在你的本机上，除了您本人，其他人都无法获取您的策略信息，绝对安全。 优品量化有哪些风控策略？ 优品量化提供如下风控策略： 购买力风控 亏损风控 仓位风控 策略风控 策略ID有什么用？如何产生的？ 策略ID用于用户策略回测识别某个回测实例，从而运行该回测实例。每次创建回测示例就会生成一个回测ID。 支持哪些Python库？ 策略在您的本地运行，您用到的Python库可以自行进行安装。 回测问题 可以支持tick级别回测吗？ 可以。优品量化支持日频、分钟频和tick频。 按日线、分钟线和tick回测的区别 按日回测，每天9点（期货）或9点半（股票）调用一次行情函数 按分钟回测，每分钟调用一次行情函数 按tick回测，每5秒调用一次行情函数 不同市场的tick数据推送频率是否相同？ 不同市场的tick数据推送频率不同，优品量化推送tick数据的频率如下： 代号 交易所名称 tick推送频率 CS 上交所（SH） 5秒 CS 深交所（SZ） 5秒 CF 中金所（CFFEX） CF 上期所（SHFE） CF 郑商所（ZCE） CF 大商所（DCE） 回测股票策略时如何处理复权、拆分、分红等变化？ 当股票发生分红拆分时，股价会发生变化，往往在股价走势图上出现向下的跳空缺口。在回测部分我们默认提供前复权的数据，用户也可以选择采用不复权的数据，利用我们提供的复权因子数据自行计算除权除息，若使用不复权的数据，则系统会在回测时自动处理好除权除息的问题，计算对应的价格和数量。 模拟交易问题 模拟交易有什么用处？ 模拟交易是一个符合交易规则的高度契合真实环境的交易系统，可以检验策略回测结果可靠性，避免您直接从回测到实盘试错浪费钱。 模拟交易和回测有什么区别？ 回测成交量不会超过当天的最大成交量（或当天成交量的一部分），模拟交易则是全部成交。这会导致相同日期同一策略的回测结果和模拟交易的结果不一样。另外，按天模拟的交易暂不支持限价单。 一个账户能能否同时运行多个模拟交易？ 可以。优品量化支持多用户多账号多实例运行。 模拟交易中哪些参数可以调整优化？ 在模拟交易和实盘交易中，策略模块设置的默认参数不需要修改代码，可以直接在界面做调整，更方便您操作。 平台使用问题 使用SDK常见错误码问题 1.用户ID不存在 报错信息截图如下： 修改步骤：检查配置文件config中的user是否与量化平台右上角的SDK_User一致，若不一致修改之即可。 2.TOKEN错误 报错信息截图如下： 修改步骤：检查配置文件config中的token是否与量化平台右上角的SDK_Token一致，若不一致修改之即可。 3.文件不存在 报错信息截图如下： 修改步骤：检查是否有命名为如图test1的文件，如果不存在此文件，在config对应的位置改成需要运行的文件名即可 4.策略不存在 报错信息截图如下： 修改步骤：检查配置文件config中的”name“配置的是否和实例中模块参数下的策略名一致，若不是修改之即可。 5.策略ID不存在 报错信息截图如下： 修改步骤：检查config配置文件中的”instance_id“是否和量化平台界面要运行的实例ID一致，若不一致点击”复制ID“按钮，然后粘贴到config配置文件对应位置即可 更多错误码原因 错误码eno 英文解释 中文解释 0 succ 成功 5 The parameter is empty 参数为空 6 Parameter is not a number 参数不是数字 7 Memory allocation failed 内存分配失败 8 datas is not ready! 云端数据准备中 9 Unsupported interface 不支持的接口 10 Data compression failed 数据压缩失败 11 Data decompression failed 数据解压失败 12 File does not exist 文件不存在 13 Data read and write exception 数据读写异常 14 Invalid argument 参数无效 15 Data does not exist 数据不存在 16 Data has not changed 数据未发生变化 50 Not found refdata 未找到标的REFDATA 51 Database configuration not found 数据库配置未找到 52 There is no corresponding Adaptor code 没有对应的Adaptor代码 53 There is no corresponding RESCONTAINER code 没有对应RESCONTAINER 54 RESCONTAINER already exists RESCONTAINER已经存在 55 The server is not initialized 服务端未初始化 56 Invalid market time period 无效的市场时间段 57 Network request REFDATA failed 网络请求REFDATA失败 58 Network request market information failed 网络请求市场信息失败 59 Network request Kbar failed 网络请求Kbar失败 60 ExFactor data does not exist 不存在复权数据 61 Network request ExFactor failed 网络请求ExFactor失败 62 REFDATA configuration error REFDATA配置错误 63 Trading day is not a valid contract 交日易非有效合约 80 ALGO node does not exist ALGO节点不存在 81 ALGO node not configured ALGO节点未配置 82 ALGO does not match ALGO节点不匹配 83 ALGO duplicate node configuration ALGO节点配置重复 100 userId duplicate 用户ID重复 101 userId not exists 用户ID不存在 102 accountId does not exist 用户账号不存在 103 userId duplicate 用户账号重复 104 account not enough money 用户账号下资金不够 105 account symbol duplicate 用户账户下存在相同股票代码 106 account symbol not exists 用户账户下不存在股票代码 107 password error 用户密码错误 108 symbol not support 不支持symbol 109 userid empty 用户ID为空 110 userid invalid 非法用户ID 111 userid not match 用户ID不匹配 118 sdk version error sdk 版本错误 119 token error TOKEN错误 150 position list has opposite 仓位记录中有反向仓位 200 quote not in cache 未找到对应的行情数据 202 Read K line exception 读取K线异常 203 Combined K line anomaly 合并K线异常 204 Open sqlite handle failed 打开sqlite句柄失败 205 Sqlite execution failed sqlite执行失败 206 Bar does not exist bar不存在 207 Save K line exception 保存K线异常 208 Invalid K line data 无效的K线数据 257 Order quantity must be greater than 0 订单的数量必须大于0 258 Limit order price must be greater than 0 限价单的价钱必须大于0 259 Insufficient cash available 可用现金不足 263 Account state must be active. 账户状态必须为活跃 264 Position Qty should be greater than the Qty of OS_SELL Order T+N标的，或者不可以卖空的标的, 检查标的仓位要大于等于此次订单的卖出的数量 265 Ceil or Floor invalid 标的有涨跌停，必须校验订单价格 266 MarketSession is not the trading time. 当前不是交易时间 267 Qty of order is not the integer multiple of 'lot size' . 订单数量不是lot size的整数 268 Refdata does not include the order's info. Refdata中不存在此标的 269 Qty of order is greater than the allowed maximum Qty 下单数量超过最大交易所允许数量 270 Incompleted orders' qty is greater than the default qty (300) . 用户最大未完成订单超过一定数量 271 Uers' trading frequency is greater than the default value in 1 sec / 1 min. 同一用户对于同一股票一秒（1）或者一分钟（20）下单数量超过阈值 273 Symbol Trade Suspension. 当前标的今日停牌中 300 Strategy Not Exists. 策略不存在 301 Analyzer Not Exists. 分析器不存在 302 Strategy Template Not Exists. 策略模块不存在 303 Strategy Start Failed. 策略启动失败 304 Strategy Export Failed. 策略导出失败 305 No Symbol Configured. 未配置任何标的 306 Lang Not Match. 语言类型不匹配 307 Analyzer Not Match. 分析器类型不匹配 308 Not Support External Analyzer. 系统策略不支持用户分析器 309 Analyzer Params Loss. 分析器参数缺失 310 Analyzer Params Loss. 分析器参数缺失 311 Strategy Create Fail. 策略创建失败 312 Strategy Analyzer Lang Not Match. 策略和分析器语言不匹配 313 Not External Analyzer. 请选择至少一个用户模块 314 Symbol Have No Account. 策略标的没有配置对应的账户 315 Symbol Num More Than One. 标的数目的大于一 316 Symbol Not Found. 标的未找到 317 Strategy Run Exception. 策略运行异常 318 Strategy Symbol Position Not Found. 标的仓位未找到 320 Wrong Order Side. 错误的交易方向 321 Analyzer Param Loss. 分析器参数缺失 322 Analyzer Param Invalid. 分析器参数无效 323 Analyzer Register Fail. 分析器注册失败 324 Account Confused. 账号混淆 325 Quote Confused. 行情混淆 326 Symbol Strategy Position Not Exist. 标的策略仓位不存在 327 Order Confused. 订单混淆 328 Analyzer Name Repeat. 分析器名称重复 329 Internal Analyzer Name Repeat. 内置分析器名称重复 330 Analyzer is Using. 分析器正在使用 331 External Strategy Not Support Non-Remote. 外置策略不支持非远程模式 332 Analyzer Run Error. 分析器运行错误 333 Strategy Symbol Account Invalid. 获取标的账号失败，标的所属账号无效 334 Update Strategy Account Failed. 更新策略账号失败,策略没有该账号 335 Update Symbol OverallPosition Failed. 更新策略标的汇总仓位失败,策略不存在该标的 336 Strategy focus symbols exceed limited! 策略关注标的超过限制 360 Order Pending Too Long. 执行器订单挂起超时 361 Execution State Unexpected. 执行器状态异常 362 Execution Failed Too Many Times. 执行器失败次数太多 400 No Symbol Configured. 没有配置标的 401 Date Invalid. 回测区间无效 402 BackTest Id Not Exist. 回测ID不存在 403 Strategy Not Init. 策略未初始化 404 BackTest Remote Mode. 回测为远程模式 405 Market Init Fail. 市场模块初始化失败 406 DownStream Init Failed. 下单模块初始化失败 407 User Auth Failed. 用户验证失败 408 Strategy Not Exist. 策略不存在 409 BackTest Not Stop. 回测未处于停止状态 410 BackTest Have No Record. 没有回测结果记录 411 BackTest Started. 回测已经开始 412 BackTest Not Running. 回测未运行 413 BackTest Can not Start. 回测无法开始 414 BackTest User Not Exsit. 用户不存在 415 BackTest ID Not Match. 回测ID不匹配 416 BackTest Instance Too Many. 同时运行的回测实例太多 417 Symbol Have No RefData. 标的RefData未配置 418 Strategy Template Has Changed, Please try create a new BackTest Instance. 策略模板已经变更, 请重新创建回测实例 500 Replay quote timeout. 回放行情数据超时,可能当前回放行情用户过多或同时关注标的太多 9990 Terminated by ctrl+c! Ctrl+c终止 9999 Connect Time Out!Please check out your configuration again! 连接超时，请检查配置之后重试 60000 loss config param! 缺少启动参数 60001 config file not exists! 配置文件不存在 60002 get strategy info failed! 获取策略信息失败 60003 Failed to get backtest parameters 获取回测参数失败 60004 Initialization signal daata failed 初始化信号数据失败 60005 Missing analyzer 缺少分析器 60006 Preload bar data timeout 初始化信号数据失败 60007 Start backtest failed 启动回测失败 60008 Preload data timeout 初始化信号数据失败 60009 Network request timeout 网络请求超时 没有触发onBar回调原因 1.先检查在onBeforeMarketOpen事件中是否setFocusSymbols相关标的，若无请设置 2.若已设置相关标的仍未响应onBar，再检查所设置标的是否停牌，看所选频率是不是非tick的 没有触发onHandleData回调原因 1.先检查在onBeforeMarketOpen事件中是否setFocusSymbols相关标的，若无请设置 2.若已设置相关标的仍未响应onHandleData，检查onInitialize中是否有配置setGroupMode 3.若已配置setGroupMode仍未响应，再检查所设置标的是否停牌 getBarsHistory获取不到历史K线的原因 在onInitialize中没有设置相关标的的缓存数据，参考setRequireBars-设置行情数据缓存条数 期货交易是否有结算处理 有，模拟盘和实盘在每个交易日的下午5点结算 优品的数据是什么时候更新的？ tick,bar实时更新 日线当天17:00结算更新 主力合约当天17:00结算后更新 日频因子当天17:00结算更新 季频因子第二天凌晨3:00更新 level2因子数据第二天凌晨5:00更新 其他问题 什么是主力合约？什么的当月连续合约？ 主力合约定义如下： （1）以过去三天的平均持仓量排名为第一名的，则切换该合约为主力合约 （2）品种上市第一天，主力合约为交割日最近的合约 （3）向前切换不回退 （4）每日收盘结算后计算 当月连续、下月连续、下季连续、隔季连续分别用M0,M1,M3,M6表示，如'IFM0'，'IFM1'，'IFM3'，'IFM6'表示沪深300期货当月、下月、下季、隔季连续合约。 举例：如果今天是17年6月29，那么IF类的当月连续就是“IF1707”，因为IF1706在6月16号已经交割了（每个月的第三个周五），下月连续就是“IF1708”，下季连续是“IF1709”，隔季连续是“IF1712”；如果今天是17年7月3号，那么那么IF类的当月连续就是“IF1707”，因为IF1707还未到交割日（每个月的第三个周五），下月连续就是“IF1708”，下季连续是“IF1709”，隔季连续是“IF1712”。 "},"apiold9.html":{"url":"apiold9.html","title":"API文档  (旧版)","keywords":"","body":"API文档（旧版） 一个简单的策略 以下是一个简单的买入标的池中的标的并持有的策略，用来说明一个基本的策略完成所需的模块，更多的策略详见策略示例。 from etasdk import * #初始化 def onInitialize(api): api.setSymbolPool(instsets=[\"000016.IDX\"]) pass #盘前运行，必须实现，用来设置当日关注的标的 def onBeforeMarketOpen(api, tradeDate): symbolPool = api.getSymbolPool() # 获取初始化中设置的标的池 print(\"symbolPool---\", len(symbolPool)) symbols = [] for symbol in symbolPool: symbols.append(symbol) print(symbol) api.setFocusSymbols(symbols) # 从标的池中筛选标的设置为关注，被关注和在持仓中的标的当天能够收到行情推送 #Bar调用 def onBar(api, bar): print (\"onbar: %d\"%bar.tradeDate) api.targetPosition(bar.symbol, 100) #对该标的进行下单 #运行终止调用 def onTerminate(api, exitInfo): print (\"onTerminate\") print (exitInfo) 深度理解API（必看） 主要问题 为了高效的使用API, 需要对平台的机制有一定的了解. 优品量化的平台最核心的特点是SDK模式, 本机安装SDK后, 策略基于SDK实现, 和云端量化引擎通讯来完成策略的运行, 同时策略运行过程中, 数据也需要自动的从云端拉取到本地. 那么为了保证策略运行的高效性, 就需要考虑如下几个问题: 这么大量的数据, 如何保证拉取数据的效率? 策略运行过程中, 播放K线时如果保证效率? 为了解决这两个问题, API提供了相关机制来控制和优化效率: 设置数据 在onInitialize中调用setRequireData来设置需要的数据: 个股, 标的池(市场, 板块,期货品种等) K线类型和历史根数 A股各类因子#设置股票池、相关标的因子数据和K线。 api.setRequireData(instsets=[\"000016.IDX\",\"cu.PRD\"],symbols=[\"IFZ0.CF\",\"000001.CS\"],fields=[\"CIRC_CAP\", \"TURNOVER_RATE\", \"PE\"],bars=[(ETimeSpan.DAY_1,2),(ETimeSpan.MIN_1,2)]) #设置股票池、相关标的因子数据和K线。 api.setRequireData(instsets=[\"000016.IDX\",\"cu.PRD\"],fields=[\"CIRC_CAP\", \"TURNOVER_RATE\", \"PE\"],bars=[(ETimeSpan.DAY_1,2),(ETimeSpan.MIN_1,2)]) #设置股票池、相关标的因子数据和K线。 api.setRequireData(symbols=[\"IFZ0.CF\",\"000001.CS\"],fields=[\"CIRC_CAP\", \"TURNOVER_RATE\", \"PE\"],bars=[(ETimeSpan.DAY_1,2),(ETimeSpan.MIN_1,2)]) #设置股票池和K线。 api.setRequireData(instsets=[\"000016.IDX\",\"cu.PRD\"],symbols=[\"IFZ0.CF\",\"000001.CS\"],bars=[(ETimeSpan.DAY_1,2),(ETimeSpan.MIN_1,2)]) #设置股票池和相关标的因子数据 api.setRequireData(instsets=[\"000016.IDX\",\"cu.PRD\"],symbols=[\"IFZ0.CF\",\"000001.CS\"],fields=[\"CIRC_CAP\", \"TURNOVER_RATE\", \"PE\"]) onInitialize在策略启动后只会调用一次, 在策略运行过程中, 只会拉取相关的数据. 因此在实现策略过程中, 尽量只设置自己需要的数据, 避免拉取太多数据, 这有助于提高策略运行的性能. 减少K线播放量 策略运行过程中, 云端量化引擎会播放相应的K线来驱动策略运行.SDK中的onBeforeMarketOpen每个交易日开盘前会响应一次, 策略可以在这个函数中执行选股逻辑, 然后调用setFocusSymbols来关注选出来的标的. 注意: 只有setFocusSymbols的股票以及持仓的标的才会收到当天的行情推送. 比如:在onInitialize中, api.setRequireData设置了A股全市场(CS.SET), 但是每天选股过程中只会选取几只股票, 并对这几只股票做买卖操作, 因此只需要setFocusSymbols这几只股票, 从而大幅度提升了效率. K线的三种播放机制 onHandleData模式: onBeforeMarketOpen中focus了多少标的, 都只会回调onHandleData一次. onBar模式: onBeforeMarketOpen中setFocusSymbols的标的+持仓标的, 每个标的都会收到onBar的回调, 比如 setFocusSymbols标的+持仓标的有10只, 播放是日K行情, 那么当天onBar会有10次回调; onHandleData/onBar混合模式: 两者都会回调 onInitialize中通过调用api.setGroupMode来控制播放模式, 默认不调用api.setGroupMode则是onBar模式 #设置只响应onHandleData，超时时间为5000ms api.setGroupMode(timeOutMs=5000, onlyGroup=True) #设置既响应onHandleData，也响应onBar，超时时间为10000ms api.setGroupMode(timeOutMs=10000, onlyGroup=False) timeOutMs用于在模拟盘/实盘情况下, 如果超过timeOutMs, 相应的K线还没有到齐, 则不再等待, 直接回调onHandleData. 数据结构 RefData-股票基础信息 属性 类型 说明 symbol str 标的代码 marketName str 品种名称。CS-股票；CF-期货；IDX-指数 exchange str 交易所及自定义类型后缀。SZ-深交所；SH上交所；DCE-大商所；SHFE-上期所；CZCE-郑商所；CFFEX-中金所；PLATE-板块；SET-证券集合 currency str 币种 lotSize double 一手标的的数目 name str 标的名称 tplus int T+N交易。例如tplus为1时为t+1交易 marginRate double 保证金比例 shortSellable bool 是否可卖空 valuePerUnit double 合约乘数 priceTick double 标的价格浮动最小单位值 exchSymbol str 交易所的原始symbol isStandard bool 是否是交易所的标准合约，比如主力合约 IFZ0.CF 就不是交易所的标准合约 tradeMarket str 该标的对应的交易市场，目前仅有 CS CF listDate int 上市日，无则为0 lastTradeDate int 最后交易日(退市日)，无则为0 Tick-Tick行情信息 属性 类型 说明 symbol str 标的代码 bid double 买一价 ask double 卖一价 bidVol double 买一量（单位为实际证券股数） askVol double 卖一量 last double 最新成交价 lastVolume double 最新成交量 lastTurnover double 最新成交额 totalVolume double 交易日总成交量 totalTurnover double 交易日总成交额 high double 交易日最高价 low double 交易日最低价 open double 交易日开盘价 close double 交易日收盘价 tradeDate long 交易日-年月日，格式为YYYYMMDD timeExch long 交易所的实时时间戳-年月日时分秒 (ms) timeStr str 交易时间，格式为YYYYMMDD-hhmmss-xxx bids vector 五档买价，包括数量和价格，qtyprice{\"quantity\":qty,\"price\":price} asks vector 五档卖价，包括数量和价格 ceil double 涨停价 floor double 跌停价 position double 持仓量(期货) preClose double 昨日收盘价 preSettle double 昨日结算价 Bar-Bar数据信息 属性 类型 说明 symbol str 标的代码 tradeDate long 交易日-年月日，格式为YYYYMMDD timeStop long bar对应的截止时间戳 (ms) timeStr str 交易时间，格式为YYYYMMDD-hhmmss-xxx timeSpan long K线的时间频率 high double 交易日最高价 low double 交易日最低价 open double 交易日开盘价 close double 交易日收盘价 volume double KBar成交额 turnover double KBar成交量 totalVolume double 交易日总成交量 totalTurnover double 交易日总成交额 preClose double 昨日收盘价 settle double 结算价 preSettle double 昨日结算价 position double 持仓量 isSuspended bool 是否停牌 SymbolPosition-策略持仓信息 某一个策略中某只标的的仓位信息。 属性 类型 说明 symbol str 标的代码 positionSide PositionSide 持仓方向 posQty double 持仓数量，不包括挂单的仓位 posDailyQty double 当日开仓的持仓数量，不包括挂单的仓位 posPrice double 持仓均价 posHigh double 持仓以来最高价 posLow double 持仓以来最低价 posTime long 开仓时间（时间戳） posUrPnL double 仓位总浮动盈亏 availableQty double 今日可平仓数量 posDailyOverallPnL double 当日盈亏=当日浮动盈亏+当日平仓盈亏，结算时清零 posTradeDate int 开仓交易日，格式为YYYYMMDD posMargin double 仓位占用保证金 posMarketValue double 仓位市值 StrategyPnL-策略盈亏信息 策略的整体盈亏信息。 属性 类型 说明 id double 策略ID urPnL double 策略的总浮动盈亏 overallPnL double 策略的整体总盈亏，包含平仓盈亏 dailyPnL double 策略的当日盈亏=当日浮动盈亏+当日平仓盈亏，结算时清零 totalCommission double 策略总手续费 OverallPosition-账户标的持仓信息 由于多个策略可以共享账户资金，因此可能会存在多个策略中都持有某个标的的情况，账户中会将多个策略中标的信息进行汇总。 属性 类型 说明 accountId str 账户ID symbol str 标的代码 buyPrice double 加权平均买价 sellPrice double 加权平均卖价 buyQty double 买数量 sellQty double 卖数量 longQty double 多仓持仓数量 shortQty double 空仓持仓数量 longPrice double 多仓持仓均价 shortPrice double 空仓持仓均价 longLastUrPnL double 多仓浮动盈亏 shortLastUrPnL double 空仓浮动盈亏 lastUrPnL double 总持仓总浮动盈亏 longAvailableQty double 多仓可平仓数量 shortAvailableQty double 空仓可平仓数量 longMargin double 多仓占用保证金 shortMargin double 空仓占用保证金 longMarketValue double 多仓持仓市值 shortMarketValue double 空仓持仓市值 Account-账户信息 属性 类型 说明 id str 账户ID market str 市场 currency str 账户币种 dailyPnL double 当日平仓盈亏，结算时清零 urLastPnL double 浮动盈亏 allTimePnL double 平仓盈亏 cashDeposited double 累积出入金 cashAvailable double 可用现金 = 现金 + 浮盈亏 - 市值 - 手续费（A股现金分红也在可用资金里 ） unitValue double 账户基金净值 bonus double 现金分红 margin double 持仓占用资金 marketValue double 持仓市值 totAssets double 总资产 totalCommission double 总手续费 Order-订单委托信息 属性 类型 说明 symbol string 标的代码 side EOrderSide 买卖方向 positionSide EPositionSide 订单持仓方向 positionEffect EPositionEffect 订单开平仓类型 qty double 委托量 price double 委托价 userId string 用户id accountId string 账户id created long 委托创建日期 id string 订单id tradeDate int 交易日 strategyId string 所属策略id portfolioId string 组合id commission commission 手续费 tradeAccount string 交易账号 externalOrderId string SDK生成的ID-SDK orderType EOrderType 订单委托类型，市价或限价单 ordStatus EOrdStatus 订单状态 cumQty double 已成交数量 avgPx double 已成交均价 tif TimeInForce 订单时间状态 modified long 委托最后修改日期 execType EExecType 订单执行状态 枚举类型 ETimeSpan-频率类型 enum ETimeSpan { TICK , //tick类型 MIN_1 , //1分钟K线 MIN_5 , //5分钟K线 MIN_15 , //15分钟K线 MIN_30, //30分钟K线 MIN_60, //60分钟K线 DAY_1, //日K线 }; EPriceMode-复权模式 enum EPriceMode { REAL, //不复权 FORMER, //前复权 }; EPositionSide-持仓方向 enum EPositionSide { LONG = 1, //多仓 SHORT = 2, //空仓 }; EPositionEffect -订单开平仓类型 enum PositionEffect { OPEN = 1, //开盘价 CLOSE = 2, //收盘价 CLOSE_TODAY = 3, //当日收盘价 CLOSE_YESTERDAY = 4, //昨日收盘价 }; EOrderSide-买卖方向 enum EOrderSide { BUY = 1, //买入 SELL = 2,//卖出 }; EOrderType -订单类型 enum EOrderType { MARKET = 1, //市价单 LIMIT = 2, //限价单 }; EOrdStatus-订单状态 enum EOrdStatus { NONE = 0, NEW = 1, //新单 PARTIALLY_FILLED=2, //部分成交 FILLED= 3, //全部成交 DONE_FOR_DAY=4, //今日完结 CANCELED=5, //撤销 REPLACED=6, //修改 PENDING_CANCEL=7, //正在撤销 STOPPED=8, //终止 REJECTED=9, //拒绝 SUSPENDED=10, //挂起 PENDING_NEW=11, //正在创建 CALCULATED=12, //正在计算 EXPIRED=13, //过期 ACCEPTED_FOR_BIDDING=14, //正在接受交易 PENDING_REPLACE=15, //正在修改 }; EExecType-订单执行状态 enum EExecType { NONE = 0, NEW = 1, //新单 PARTIALLY_FILLED=2, //部分成交 FILLED= 3, //全部成交 DONE_FOR_DAY=4, //今日完结 CANCELED=5, //撤销 REPLACED=6, //修改 PENDING_CANCEL=7, //正在撤销 STOPPED=8, //终止 REJECTED=9, //拒绝 SUSPENDED=10, //挂起 PENDING_NEW=11, //正在创建 CALCULATED=12, //正在计算 EXPIRED=13, //过期 ACCEPTED_FOR_BIDDING=14, //正在接受交易 PENDING_REPLACE=15, //正在修改 }; ETimeInForce-订单委托属性 enum ETimeInForce { NONE = 0, //未指定，如果不指定;则限价单默认为DAY,市价单默认为 IMMEDIATE_OR_CANCEL DAY = 1, //订单在交易日内有效，会自动取消 GOOD_TILL_CANCEL = 2, //暂时不支持—订单一直有效，直到投资者主动撤销订单（一般也有默认有效期30~90天） AT_THE_OPENING = 3, //暂时不支持-订单在开市的时候被执行，如果开盘内不能执行，则取消；通常是开盘前集合竞价或者开盘前的瞬间 IMMEDIATE_OR_CANCEL = 4, //订单必须立即执行，不能被立即执行的部分将被取消 FILL_OR_KILL = 5, //订单必须被完全执行或者完全不执行 GOOD_TILL_CROSSING = 6, //暂时不支持- GOOD_TILL_DATE = 7, //暂时不支持-订单一直有效，直到指定日期 AT_THE_CLOSE = 8, //暂时不支持-订单在交易最后执行（或者尽可能接近收盘价），通常是收拾撮合的时间段 }; EtaPriceList-报价列表 enum EtaPriceList { EPriceList.NONE = 0, EPriceList.BID1 = 1, //买一价 EPriceList.BID2 = 2, //买二价 EPriceList.BID3 = 3, //买三价 EPriceList.BID4 = 4, //买四价 EPriceList.BID5 = 5, //买五价 EPriceList.BID6 = 6, //买六价 EPriceList.BID7 = 7, //买七价 EPriceList.BID8 = 8, //买八价 EPriceList.BID9 = 9, //买九价 EPriceList.BID10 = 10, //买十价 EPriceList.ASK1 = 101, //卖一价 EPriceList.ASK2 = 102, //卖二价 EPriceList.ASK3 = 103, //卖三价 EPriceList.ASK4 = 104, //卖四价 EPriceList.ASK5 = 105, //卖五价 EPriceList.ASK6 = 106, //卖六价 EPriceList.ASK7 = 107, //卖七价 EPriceList.ASK8 = 108, //卖八价 EPriceList.ASK9 = 109, //卖九价 EPriceList.ASK10 = 110, //卖十价 }; 需要实现的事件 onInitialize-初始化 函数原型： onInitialize(api) 说明： 在策略运行前会调用一次，用来进行初始化。行情数据缓存需要在这个事件中实现。 onBeforeMarketOpen-盘前运行 函数原型： onBeforeMarketOpen(api,tradeDate) 说明： tradeDate表示当前日期，开盘前调用一次，选股的逻辑可以在这个函数中实现，可以根据策略的复杂度在创建实例时设置盘前策略运行时间。 onTick-tick产生 函数原型： onTick(api,tick) 说明： tick产生时会调用，目前仅期货市场支持tick。 onFirstTick-第一根tick触发 函数原型： onFirstTick(api,tick) 说明： 第一根tick产生时会调用，目前仅期货市场支持tick。可用于撮合周期为非tick级别来获取当日涨跌停价，以此做止盈止损，回测不支持此回调。 onBar-Bar产生 函数原型： onBar(api,bar) 说明： 创建实例时设置撮合周期，bar产生时会调用。为了提高效率，只有在关注列表（即setFocusSymbols设置的标的列表）中和有持仓的标的才会响应行情回调。 onHandleData-数据到齐后触发 函数原型： def onHandleData(api,timeExch) 说明： 针对某一周期的bar数据，搜集齐后再统一响应回调，timeExch为当前周期的时间戳。对于回测，数据可以都到齐；对于模拟盘和实盘，不一定能够都到齐，需要设置超时时间。默认只回调onBar，如需回调onHandleData则需在onInitialize中配置setGroupMode函数，详见setGroupMode。 示例： from etasdk import * from etasdk.utils.time_util import TimeUtil #初始化 def onInitialize(api): api.setRequireBars(ETimeSpan.MIN_1, 10);#准备1分钟K线 api.setGroupMode(5000,True)#设置收齐数据超时为5s，True表示只回调onHandleData， false表示既回调onHandleData也回调onBar symbolPool=[] #盘前运行，必须实现，用来设置当日关注的标的 def onBeforeMarketOpen(api,tradeDate): global symbolPool print \"onBeforeMarketOpen----\",tradeDate symbolPool=api.getSymbolPool() api.setFocusSymbols(symbolPool) #数据收齐回调 def onHandleData(api,timeExch): print (\"onHandleData---time_stamp %s\" % TimeUtil.msToTimeString(api.timeNow())) for symbol in symbolPool: print (api.getBarsHistory(symbol, ETimeSpan.MIN_1, 1, df=True)) onTerminate-运行终止 函数原型： onTerminate (api, exitInfo) 说明： 运行终止时会调用一次,exitInfo返回值为终止消息。 onTimer-定时器 函数原型： onTimer (api) 说明： 每隔5000毫秒会响应一次。 onOrderUpdate-订单状态更新回调 函数原型： onOrderUpdate(api,order) 说明： 订单状态更新时会响应一次，order为订单详情。 设置函数 setRequireData-设置策略所需缓存数据（包含K线、股票池和日频、季频、财务数据字段） 在onInitialize函数中调用，设置缓存数据（包含K线、股票池和日频、季频、财务数据字段），是函数setRequireFields、setRequireBars和setSymbolPool的整合。 函数原型： setRequireData(instsets=None, symbols=None, fields=None, bars=None) 参数： 参数 类型 是否必填 说明 instsets list 否 设置标的集合，如000300.IDX、CS.SET等 symbols list 否 设置标的列表。 fields str or list 否 设置数据属性，可以是多个字段 bars list[tuple(ETimeSpan, int)] 否 设置缓存K线条数，可以设置多个频率。频率类型，详见 ETimeSpan 举例： #设置股票池、相关标的因子数据和K线。 api.setRequireData(instsets=[\"000016.IDX\",\"cu.PRD\"],symbols=[\"IFZ0.CF\",\"000001.CS\"],fields=[\"CIRC_CAP\", \"TURNOVER_RATE\", \"PE\"],bars=[(ETimeSpan.DAY_1,2),(ETimeSpan.MIN_1,2)]) #设置股票池、相关标的因子数据和K线。 api.setRequireData(instsets=[\"000016.IDX\",\"cu.PRD\"],fields=[\"CIRC_CAP\", \"TURNOVER_RATE\", \"PE\"],bars=[(ETimeSpan.DAY_1,2),(ETimeSpan.MIN_1,2)]) #设置股票池、相关标的因子数据和K线。 api.setRequireData(symbols=[\"IFZ0.CF\",\"000001.CS\"],fields=[\"CIRC_CAP\", \"TURNOVER_RATE\", \"PE\"],bars=[(ETimeSpan.DAY_1,2),(ETimeSpan.MIN_1,2)]) #设置股票池和K线。 api.setRequireData(instsets=[\"000016.IDX\",\"cu.PRD\"],symbols=[\"IFZ0.CF\",\"000001.CS\"],bars=[(ETimeSpan.DAY_1,2),(ETimeSpan.MIN_1,2)]) #设置股票池和相关标的因子数据 api.setRequireData(instsets=[\"000016.IDX\",\"cu.PRD\"],symbols=[\"IFZ0.CF\",\"000001.CS\"],fields=[\"CIRC_CAP\", \"TURNOVER_RATE\", \"PE\"]) setFocusSymbols-设置关注的标的池 只能在onBeforeMarketOpen函数中调用，必须实现。只有在此函数中进行设置的标的和当前持仓的标的才会在onBar、onHandleData或者onTick函数中进行行情响应。若没有在setFocusSymbols中set的标的并且不在持仓的不会在onBar、onHandleData和onTick中响应，并且调用getBarsHistory也拿不到当天的K线。 注：setFocusSymbols 如果多次使用，则只会记录最后一条的设置；前面的设置将会被覆盖 函数原型： setFocusSymbols(symbols) 参数： 参数 类型 是否必填 说明 symbols str or list 是 标的或标的列表 setSymbolPool-设置股票池 在onInitialize函数中调用，只有在此函数中进行设置相关股票，才能获取到对该股票设置缓存的相关K线和其他因子数据以及财务数据。股票池可以设置单个标的，也可以设置指数成分股、行业板块、特殊集合。 建议不再使用, 直接使用setRequireData代替。 函数原型： setSymbolPool(instsets = None,symbols = None) 参数： 参数 类型 说明 instsets list 设置标的集合，如000300.IDX、CS.SET等，可缺省 symbol list 设置标的列表，可缺省 举例： api.setSymbolPool(instsets=[\"CF.SET\"]) #设置股票池为期货全部，包括主力合约和次主力合约。 api.setSymbolPool(instsets=[\"000300.IDX，000016.IDX\"]) #设置股票池沪深300和上证50的并集。 api.setSymbolPool(instsets=[\"cu.PRD\"],symbols=[\"cuZ0.CF\",\"cuZ1.CF\"]) #设置股票池为期货是cu的全部标准合约（不含cuZ0.CF和cuZ1.CF）和cuZ0.CF和cuZ1.CF。 api.setSymbolPool(symbols=[\"IFZ0.CF\"]) #设置股票池为IF的主力合约 api.setSymbolPool(instsets=[\"IFZ0.CF\"]) #设置股票池为IF的主力合约对应的标准合约 api.setSymbolPool(symbols=[\"000001.CS\",\"IF1809.CF\"]) #设置股票池为000001.CS和IF1809.CF。 setRequireBars-设置行情数据缓存条数 在onInitialize函数中调用，设置Bar行情数据的数据缓存条数，即getBarsHistory函数中可以调用的历史条数，在初始化事件中进行调用。例如将日K线设置成5，则可以获取到前5个交易日的数据，随着回测时间移动之前的数据会被清掉。若需要取用多个频率的数据则需要分别设置，不设置该函数不会缓存。 建议不再使用, 直接使用setRequireData代替。 函数原型： setRequireBars(timspan,count) 参数： 参数 类型 说明 timspan ETimeSpan Bar的频率类型，详见 ETimeSpan 。 count int 设置行情数据的数据需要缓存的条数。 举例： def onInitialize(api) api.setRequireBars(ETimeSpan.DAY_1,20) #将日K的数据需要的历史数据设置成20根。 setRequireFields-设置缓存日频、季频、财务等非行情类数据 在onInitialize函数中调用，设置缓存日频、季频、财务数据字段，即getFieldsOneDay、getFieldsRangeDays、getFieldsCountDays和getStockFinFields 函数中可以调用的字段。例如设置\"TOT_SHARE\", \"SP_RESER\"，则调用前面的函数中就可以取到这两个字段的值，否则取不到值。不设置该函数就不会缓存。 建议不再使用, 直接使用setRequireData代替。 函数原型： setRequireFields(fields) 参数： 参数 类型 说明 fields str or list 设置数据属性，可以是多个字段。 举例： def onInitialize(api) api.setRequireFields(fields=[\"TOT_SHARE\", \"SP_RESER\", \"PE\"]) #设置需要获取的字段。 setGroupMode-设置到齐回调模式 在onInitialize函数中调用，若不调用本函数，则只响应onBar。 函数原型： setGroupMode(timeOutMs,onlyGroup) 参数： 参数 类型 是否必填 说明 timeOutMs int 是 超时时间，单位为毫秒，最好设置不少于5000ms onlyGroup bool 是 True-只回调onHandleData ，False- 既回调onHandleData也回调onBar 举例： #设置只响应onHandleData，超时时间为5000ms api.setGroupMode(timeOutMs=5000, onlyGroup=True) #设置既响应onHandleData，也响应onBar，超时时间为10000ms api.setGroupMode(timeOutMs=10000, onlyGroup=False) setTimerCycle-设置定时回调频率 在onInitialize函数中调用，设置onTimer定时回调函数的响应周期。在回测环境下无效。 函数原型： setTimerCycle(cycle) 参数： 参数 类型 是否必填 说明 cycle int 是 响应时间间隔，单位为毫秒。 举例： #设置定时回调频率为5000ms api.setTimerCycle(cycle=5000) 交易函数 targetPosition-下单 目标仓位数量下单 函数原型： targetPosition (symbol,qty,price=None,positionSide=None,tif =ETimeInForce.NONE,remark=None,priceList=EPriceList.None) 参数： 参数 类型 是否必填 说明 symbol str 是 策略中的标的代码 qty int 是 交易量 price double 否 价格，默认不传参（表示以市价下单），若传参则表示以该委托价下限价单 positionSide EPositionSide 否 多或者空，不填时默认为多仓，股票不能为short。详见 EPositionSide tif ETimeInForce 否 下单属性说明，不填和填None时效果相同，详见ETimeInForce-订单委托属性 remark str 否 下单原因说明，填写后可以在web端展示 priceList EtaPriceList 否 报价列表，用于下限价单。若与price同时传参，则以price为准，详见EtaPriceList-报价列表 返回值： orderID。orderID作为对此条下单操作的标识。 举例： 股票下单 #以市价单买入100股000001 api.targetPosition (symbol=\"000001.CS\",qty=100) #以11元限价单买入100股000001 api.targetPosition (symbol=\"000001.CS\",qty=100,price=11) #以市价单卖出000001股票至持仓为0 api.targetPosition (symbol=\"000001.CS\",qty=0,remark=\"卖出平仓\") #以限价单卖一价买入000001股票至持仓为100股 api.targetPosition (symbol=\"000001.CS\",qty=100,priceList=EPriceList.ASK1) 期货下单 #IF1809市价单开多1手 api.targetPosition (symbol='IF1809.CF',qty=1,positionSide=EPositionSide.LONG) #IF1809市价单开空1手 api.targetPosition (symbol='IF1809.CF',qty=1,positionSide=EPositionSide.SHORT) cancelOrder-撤单 取消订单 函数原型 cancelOrder(symbol, positionSide=EPositionSide.LONG, remark=\"\") 参数： 参数 类型 是否必填 说明 symbol str 是 策略中的标的代码 positionSide EPositionSide 否 多或者空，不填时默认为多仓，股票不能为short。详见 EPositionSide 。 remark str 否 撤单原因说明，填写后可以在web端展示 举例： #撤销股票000001.CS的挂单 api.cancelOrder(symbol=\"000001.CS\",remark=\"撤销000001.CS的挂单\") #撤销期货rb1901.CF的空头挂单 api.cancelOrder(symbol=\"rb1901.CF\", positionSide=EPositionSide.SHORT) 标的查询函数 getSymbolPosition-获取单个标的仓位 获取标的仓位信息 函数原型： getSymbolPosition (symbol,positionSide=None) 参数： 参数 类型 是否必填 说明 symbol str 是 标的代码 EPositionSide positionSide 否 多或者空，不填时默认为多仓，股票不能为short。详见EPositionSide 。 返回值：SymbolPosition对象。 举例： #获取股票000001.CS仓位信息 symbolposition = api.getSymbolPosition (symbol=\"000001.CS\") #获取期货IF1809.CF多仓的仓位信息 symbolposition = api.getSymbolPosition (symbol=\"IF1809.CF\"，positionSide=EPositionSide.LONG) #获取期货IF1809.CF空仓的仓位信息 symbolposition = api.getSymbolPosition (symbol=\"IF1809.CF\"，positionSide=EPositionSide.SHORT) getSymbolPositions-获取多个/所有持仓标的仓位信息 获取所有标的仓位信息 函数原型： getSymbolPositions () 参数：无 返回值：List结构，元素为SymbolPosition对象。 举例： #获取所有标的的仓位信息 symbolpositions = api.getSymbolPositions () 账户查询函数 getAccount-获取标的所属账号信息 获取标的所属账号信息，由于账号获取是异步的，所以下完单立即获取账户数据会有延迟。 函数原型： getAccount (symbol=None, market=None) 参数： 参数 类型 是否必填 说明 symbol str 否 标的代码，可缺省，但不能同时和市场一起缺省，若都不缺省以market为准 market str 否 市场，主要有股票MARKET_CHINASTOCK和期货MARKET_CHINAFUTURE 返回值：标的所属证券的市场账号信息，Account结构。 举例： #用标的获取A股账号的信息 account = api.getAccount (symbol=\"000001.CS\") #用市场获取A股账号的信息 account = api.getAccount ( market=MARKET_CHINASTOCK) #同时填入标的和市场时，返回通过市场获取的账号信息，如下返回期货账号信息 account = api.getAccount (symbol=\"000001.CS\"， market=MARKET_CHINAFUTURE) getOverallPosition-获取标的汇总仓位 由于多个策略可以共享账户资金，因此可能会存在多个策略中都持有某个标的的情况，账户中会将多个策略中标的信息进行汇总。本函数用来获取某个标的在账户中汇总后的仓位信息。 函数原型： getOverallPosition (symbol) 参数： 参数 类型 是否必填 说明 symbol str 是 标的代码 返回值：该标的在其所属账户中的总仓位信息，OverallPosition对象结构。 举例： #获取账户下000001.CS的汇总仓位信息 overallposition = api.getOverallPosition (symbol=\"000001.CS\") #获取000001.CS仓位信息 availableQty = overallposition. longAvailableQty #获取多仓可平仓数量 策略查询函数 getStrategyPnL-获取策略盈亏信息 获取策略盈亏信息。 函数原型： getStrategyPnL() 参数值：无 返回值：策略盈亏信息，StrategyPnL对象结构 举例： getStrategyPnL= api.getStrategyPnL() #获取策略盈亏信息 overallPnL = getStrategyPnL.overallPnL #获取策略总盈亏字段数据 策略数据查询函数 策略相关数据的获取在api中进行调用。 getValueAs*-获取动态运行参数 在web页面上创建策略时可以预先设置参数，再通过api进行调用，获取策略中某策略的参数信息。页面上对参数的改动可以立即反映在策略中。 函数原型： getValueAsDouble(field) getValueAsString(field) getValueAsLong(field) 参数： 参数 类型 是否必填 说明 field str 是 参数名称 返回值： 参数值。getValueAsDouble返回float类型，getValueAsString返回string类型，getValueAsLong返回int类型。 举例： high=api.getValueAsDouble(field=\"high\") #在页面配置了名称为high的参数，获取当前策略high参数 getSymbolPool-获取股票池代码 与setRequireData 和 setSymbolPool对应，获取之前设置的股票池代码 函数原型： getSymbolPool() 参数：无 返回值： 获取之前设置的股票池代码 举例： pool=api.getSymbolPool() #获取股票池代码 getFocusAndPositionSymbols-获取持仓和当日关注的标的代码 只有当日关注和有持仓的标的才会响应行情回调函数，可以通过本函数来获取持仓和关注的标的代码。 函数原型： getFocusAndPositionSymbols() 参数：无 返回： 返回股票代码的list getPositionSymbols-获取持仓标的代码 仅获取当前有持仓的标的代码。 函数原型： getPositionSymbols() 参数：无 返回： 返回持仓标的代码的List getAppointedSymbols-获取指定合约集合 获取指定合约集合，如主力合约集合，次主力合约集合。 函数原型： getAppointedSymbols(eType, tradeDate=None) 参数： 参数 类型 是否必填 说明 eType eType 是 指定合约的类型，有Z0、Z1，Y1-Y12 tradeDate int 否 交易日 ，形式为YYYYMMDD，不填默认返回当天的数据 返回： 返回指定合约集合 举例： 获取20180710当天的所有主力合约 api.getAppointedSymbols(eType=\"Z0\", tradeDate=20180710) 返回结果 ['APZ0.CF', 'CFZ0.CF', 'CYZ0.CF', 'FGZ0.CF', 'ICZ0.CF', 'IFZ0.CF', 'IHZ0.CF', 'JRZ0.CF', 'LRZ0.CF', 'MAZ0.CF', 'OIZ0.CF', 'PMZ0.CF', 'RIZ0.CF', 'RMZ0.CF', 'RSZ0.CF', 'SFZ0.CF', 'SMZ0.CF', 'SRZ0.CF', 'TAZ0.CF', 'TFZ0.CF', 'TZ0.CF', 'WHZ0.CF', 'ZCZ0.CF', 'aZ0.CF', 'agZ0.CF', 'alZ0.CF', 'auZ0.CF', 'bZ0.CF', 'bbZ0.CF', 'buZ0.CF', 'cZ0.CF', 'csZ0.CF', 'cuZ0.CF', 'fbZ0.CF', 'fuZ0.CF', 'hcZ0.CF', 'iZ0.CF', 'jZ0.CF', 'jdZ0.CF', 'jmZ0.CF', 'lZ0.CF', 'mZ0.CF', 'niZ0.CF', 'pZ0.CF', 'pbZ0.CF', 'ppZ0.CF', 'rbZ0.CF', 'ruZ0.CF', 'scZ0.CF', 'snZ0.CF', 'vZ0.CF', 'wrZ0.CF', 'yZ0.CF', 'znZ0.CF'] 获取当天（20181127）月份为1的所有合约，若某标的同时存在1901和2001则返回较近的合约，即1901 api.getAppointedSymbols(eType=\"Y1\") 返回结果 ['OI1901.CF', 'ZC1901.CF', 'cu1901.CF', 'y1901.CF', 'WH1901.CF', 'bb1901.CF', 'FG1901.CF', 'rb1901.CF', 'sc1901.CF', 'sn1901.CF', 'RI1901.CF', 'm1901.CF', 'CY1901.CF', 'SR1901.CF', 'al1901.CF', 'a1901.CF', 'c1901.CF', 'JR1901.CF', 'fb1901.CF', 'i1901.CF', 'l1901.CF', 'RM1901.CF', 'IH1901.CF', 'ag1901.CF', 'IC1901.CF', 'IF1901.CF', 'au1901.CF', 'ru1901.CF', 'zn1901.CF', 'pp1901.CF', 'p1901.CF', 'j1901.CF', 'jd1901.CF', 'TA1901.CF', 'MA1901.CF', 'ni1901.CF', 'bu1901.CF', 'pb1901.CF', 'hc1901.CF', 'wr1901.CF', 'jm1901.CF', 'cs1901.CF', 'v1901.CF', 'b1901.CF', 'SF1901.CF', 'LR1901.CF', 'SM1901.CF', 'PM1901.CF', 'CF1901.CF', 'AP1901.CF', 'fu1901.CF'] getCurrTradeDate-获取当前交易日期 获取当前的交易日期。回测情况下是回测历史当天，交易情况下是当前交易日。 函数原型： getCurrTradeDate() 参数：无 返回值：返回历史当天的日期，int类型 getBarsHistory-获取历史K线数据 获取K线数据。模拟盘和实盘在onHandleData和onBar中获取当天的日K不是全日K线，是开盘时间到所设置的收盘时间的日K。 函数原型： getBarsHistory (symbol, timeSpan, count = None，priceMode = EPriceMode.REAL, skipSuspended = 1 ,fields=None, df=True) 参数： 参数 类型 是否必填 说明 symbol str 是 标的代码 timeSpan ETimeSpan 是 bar的频率，详见 ETimeSpan。 count int 是 获取历史数据条数，超过缓存类型的返回空 priceMode EPriceMode 否 复权模式，不填默认返回不复权，详见EPriceMode 。 skipSuspended int 否 为了保证取不同标的数据时时间对齐，可以设置是否跳过停牌， 0-不跳过，1-跳过，不填写默认为跳过。若不跳过，填充方式为高开低收均用前收盘价填充，成交量=成交额=0。 fields str or list 否 返回的字段，不填默认返回全部。 df bool 否 返回值是否采用dataFrame格式，不填默认为dataFrame格式 返回值：行情数据 ,df为false时返回Bar结构List。df为true时返回dataFrame格式。 举例： 获取不过滤停牌的前复权5分钟K线2支 #首先在def onInitialize(api)中设置缓存数据： api.setRequireData(instsets=[],symbols=[\"000001.CS\"],fields=[], bars=[(ETimeSpan.MIN_5, 5)]) #然后在对应事件回调中获取历史K线 bars = api.getBarsHistory (symbol =\"000001.CS\",timeSpan=ETimeSpan.MIN_5,count=2,priceMode=EPriceMode.FORMER,skipSuspended=0,df=False) 返回结果： [{ \"symbol\": \"000001.CS\", \"timeSpan\": 300, \"timeStop\": 1543215300000, \"timeStr\": \"20181126-145500-000\", \"tradeDate\": 20181126, \"close\": 10.32, \"high\": 10.33, \"isSuspended\": False, \"low\": 10.31, \"open\": 10.32, \"position\": 0, \"preClose\": 10.32, \"preSettle\": 0, \"settle\": 0, \"totalTurnover\": 5.24417e+08, \"totalVolume\": 5.05396e+07, \"turnover\": 1.37453e+07, \"volume\": 1.33236e+06 }, { \"symbol\": \"000001.CS\", \"timeSpan\": 300, \"timeStop\": 1543215600000, \"timeStr\": \"20181126-150000-000\", \"tradeDate\": 20181126, \"close\": 10.34, \"high\": 10.34, \"isSuspended\": False, \"low\": 10.32, \"open\": 10.32, \"position\": 0, \"preClose\": 10.32, \"preSettle\": 0, \"settle\": 0, \"totalTurnover\": 5.35963e+08, \"totalVolume\": 5.16569e+07, \"turnover\": 1.15462e+07, \"volume\": 1.1173e+06 }] 打印某个字段值： print bars[0].totalTurnover #打印交易日总成交额 返回结果： 524417138.0 获取不过滤停牌的不复权5分钟K线2组，格式为dataFrame bars = api.getBarsHistory (symbol =\"000001.CS\",timeSpan=ETimeSpan.MIN_5,count=2) 返回结果： timeStr timeStop symbol tradeDate close high low open preClose settle preSettle volume turnover totalVolume totalTurnover position isSuspended 0 20181126-145500-000 1543215300000 000001.CS 20181126 10.32 10.33 10.31 10.32 10.32 0.0 0.0 1332361.0 13745256.0 50539573.0 524417138.0 0.0 False 1 20181126-150000-000 1543215600000 000001.CS 20181126 10.34 10.34 10.32 10.32 10.32 0.0 0.0 1117298.0 11546172.0 51656871.0 535963310.0 0.0 False 获取不过滤停牌的不复权5分钟K线2支，格式为dataFrame，返回列为tradeDate，和close bars = api.getBarsHistory (symbol =\"000001.CS\",timeSpan=ETimeSpan.MIN_5,count=2,fields=['tradeDate', 'close']) 返回结果： timeStr tradeDate symbol close 0 20181126-145500-000 20181126 000001.CS 10.32 1 20181126-150000-000 20181126 000001.CS 10.34 基础数据查询函数 若想独立使用以下数据，请前往数据栏查看相关使用详情 getRefData-获取标的基本信息 获取标的基本信息。 函数原型： getRefData(symbol) 参数： 参数 类型 是否必填 说明 symbol str 是 标的代码 返回值：证券基本信息，RefData。 举例： #获取000001.CS证券基本信息 refData = api.getRefData (symbol=\"000001.CS\") 返回结果: { \"symbol\": \"000001.CS\", \"marketName\": \"CS\", \"exchange\": \"SZ\", \"currency\": \"CNY\", \"lotSize\": 100, \"name\": \"平安银行\", \"tplus\": 1, \"marginRate\": 1, \"shortSellable\": False, \"valuePerUnit\": 1, \"priceTick\": 0.01, \"exchSymbol\": 000001, \"isStandard\": True, \"tradeMarket\": CS\", \"listDate\": 19910403, \"lastTradeDate\": 0 } getConstituentSymbols-获取成分股数据 函数原型： getConstituentSymbols(indexs,tradeDate) 获取股票指数或者行业板块的成分股数据。获取期货某品种当前可交易的合约数据。详见指数代码说明。 参数： 参数 类型 是否必填 说明 indexs str or list 是 指数代码、板块代码、指数代码列表或者行业板块代码列表，为列表时表示获取的股票同时属于这些指数或者行业。 tradeDate int 否 交易日，形式为YYYYMMDD，支持获取历史成分股信息，不填默认返回当天的数据 返回： 返回股票代码的List 举例： 获取上证指数成分股 constituentSymbols = api.getConstituentSymbols(indexs=\"000001.IDX\",tradeDate=20170403) 返回结果： ['600023.CS', '600908.CS', '600909.CS', '600917.CS', '600919.CS', '600926.CS', '600936.CS', '600939.CS', '600958.CS', '600959.CS', '600977.CS', '600996.CS', '600998.CS', '600999.CS', '601000.CS', '601002.CS', '601003.CS', '601005.CS', '601007.CS', '601008.CS', '601009.CS', '601010.CS', '601011.CS', '601012.CS', '601015.CS', '601016.CS', '601018.CS', '601020.CS', '601021.CS', '601028.CS', '601038.CS', '601058.CS', '601069.CS', '601088.CS', '601098.CS', '601099.CS', '601100.CS', '601101.CS', '601106.CS', '601107.CS', '601113.CS', '601116.CS', '601117.CS', '601118.CS', '601126.CS', '601127.CS', '601128.CS', '601137.CS', '601139.CS', '601155.CS', '601158.CS', '601163.CS', '601166.CS', '601168.CS', '601169.CS', '601177.CS', '601179.CS', '601186.CS', '601188.CS', '601198.CS', '601199.CS', '601208.CS', '601211.CS', '601212.CS', '601216.CS', '601218.CS', '601222.CS', '601225.CS', '601226.CS', '601229.CS', '601231.CS', '601233.CS', '601238.CS', '601258.CS', '601288.CS', '601311.CS', '601318.CS', '601328.CS', '601336.CS', '601339.CS', '601360.CS', '601368.CS', '601369.CS', '601375.CS', '601377.CS', '601388.CS', '601390.CS', '601500.CS', '601515.CS', '601518.CS', '601519.CS', '601555.CS', '601558.CS', '601566.CS', '601567.CS', '601579.CS', '601595.CS', '601599.CS', '601600.CS', '601601.CS', '601608.CS', '601611.CS', '601616.CS', '601618.CS', '601628.CS', '601633.CS', '601636.CS', '601668.CS', '601669.CS', '601677.CS', '601678.CS', '601688.CS', '601689.CS', '601700.CS', '601717.CS', '601718.CS', '601727.CS', '601766.CS', '601777.CS', '601788.CS', '601789.CS', '601798.CS', '601799.CS', '601800.CS', '601801.CS', '601808.CS', '601811.CS', '601818.CS', '601857.CS', '601858.CS', '601866.CS', '601877.CS', '601880.CS', '601881.CS', '601882.CS', '601886.CS', '601888.CS', '601890.CS', '601898.CS', '601899.CS', '601900.CS', '601901.CS', '601908.CS', '601918.CS', '601919.CS', '601928.CS', '601929.CS', '601933.CS', '601939.CS', '601958.CS', '601965.CS', '601966.CS', '601968.CS', '601969.CS', '601985.CS', '601989.CS', '601992.CS', '601996.CS', '601997.CS', '601998.CS', '601999.CS', '603000.CS', '603001.CS', '603002.CS', '603003.CS', '603005.CS', '603006.CS', '603007.CS', '603008.CS', '603009.CS', '603010.CS', '603011.CS', '603012.CS', '603015.CS', '603016.CS', '603017.CS', '603018.CS', '603019.CS', '603020.CS', '603021.CS', '603022.CS', '603023.CS', '603025.CS', '603026.CS', '603027.CS', '603028.CS', '603029.CS', '603030.CS', '603031.CS', '603032.CS', '603033.CS', '603035.CS', '603036.CS', '603037.CS', '603038.CS', '603039.CS', '603040.CS', '603058.CS', '603060.CS', '603066.CS', '603067.CS', '603069.CS', '603077.CS', '603085.CS', '603088.CS', '603089.CS', '603090.CS', '603098.CS', '603099.CS', '603100.CS', '603101.CS', '603108.CS', '603111.CS', '603116.CS', '603117.CS', '603118.CS', '603123.CS', '603126.CS', '603128.CS', '603131.CS', '603138.CS', '603158.CS', '603159.CS', '603160.CS', '603165.CS', '603166.CS', '603167.CS', '603168.CS', '603169.CS', '603177.CS', '603179.CS', '603186.CS', '603188.CS', '603189.CS', '603198.CS', '603199.CS', '603203.CS', '603208.CS', '603218.CS', '603222.CS', '603223.CS', '603227.CS', '603228.CS', '603238.CS', '603239.CS', '603258.CS', '603266.CS', '603268.CS', '603288.CS', '603298.CS', '603299.CS', '603300.CS', '603306.CS', '603308.CS', '603309.CS', '603311.CS', '603313.CS', '603315.CS', '603318.CS', '603319.CS', '603322.CS', '603323.CS', '603328.CS', '603330.CS', '603333.CS', '603336.CS', '603337.CS', '603338.CS', '603339.CS', '603345.CS', '603355.CS', '603358.CS', '603360.CS', '603366.CS', '603368.CS', '603369.CS', '603377.CS', '603389.CS', '603393.CS', '603398.CS', '603399.CS', '603416.CS', '603421.CS', '603429.CS', '603444.CS', '603456.CS', '603508.CS', '603515.CS', '603517.CS', '603518.CS', '603519.CS', '603520.CS', '603528.CS', '603555.CS', '603556.CS', '603558.CS', '603559.CS', '603566.CS', '603567.CS', '603568.CS', '603569.CS', '603577.CS', '603578.CS', '603579.CS', '603585.CS', '603588.CS', '603589.CS', '603598.CS', '603599.CS', '603600.CS', '603601.CS', '603603.CS', '603606.CS', '603608.CS', '603609.CS', '603611.CS', '603615.CS', '603616.CS', '603618.CS', '603626.CS', '603628.CS', '603630.CS', '603633.CS', '603636.CS', '603637.CS', '603638.CS', '603639.CS', '603658.CS', '603660.CS', '603663.CS', '603665.CS', '603667.CS', '603668.CS', '603669.CS', '603677.CS', '603678.CS', '603686.CS', '603688.CS', '603689.CS', '603690.CS', '603696.CS', '603698.CS', '603699.CS', '603701.CS', '603703.CS', '603708.CS', '603716.CS', '603718.CS', '603726.CS', '603727.CS', '603729.CS', '603737.CS', '603738.CS', '603766.CS', '603777.CS', '603778.CS', '603779.CS', '603788.CS', '603789.CS', '603798.CS', '603799.CS', '603800.CS', '603806.CS', '603808.CS', '603811.CS', '603816.CS', '603817.CS', '603818.CS', '603819.CS', '603822.CS', '603823.CS', '603828.CS', '603838.CS', '603839.CS', '603843.CS', '603858.CS', '603859.CS', '603861.CS', '603866.CS', '603868.CS', '603869.CS', '603877.CS', '603878.CS', '603881.CS', '603883.CS', '603885.CS', '603886.CS', '603887.CS', '603888.CS', '603889.CS', '603898.CS', '603899.CS', '603900.CS', '603901.CS', '603903.CS', '603908.CS', '603909.CS', '603918.CS', '603919.CS', '603928.CS', '603929.CS', '603936.CS', '603939.CS', '603955.CS', '603958.CS', '603959.CS', '603960.CS', '603966.CS', '603968.CS', '603969.CS', '603977.CS', '603979.CS', '603986.CS', '603987.CS', '603988.CS', '603989.CS', '603990.CS', '603991.CS', '603993.CS', '603996.CS', '603997.CS', '603998.CS', '603999.CS'] 获取RU的可以交易标的列表 ruList=api.getConstituentSymbols(indexs=\"ru.PRD\",tradeDate=20170403) 返回结果： ['ru1704.CF', 'ru1705.CF', 'ru1706.CF', 'ru1707.CF', 'ru1708.CF', 'ru1709.CF', 'ru1710.CF', 'ru1711.CF', 'ru1801.CF', 'ru1803.CF'] 获取优品行业板块集合的列表 upList = api.getConstituentSymbols(indexs=\"UPPLA.SET\",tradeDate=20170403) 返回结果： ['880001.PLA', '880002.PLA', '880003.PLA', '880004.PLA', '880007.PLA', '880008.PLA', '880009.PLA', '880010.PLA', '880012.PLA', '880013.PLA', '880014.PLA', '880015.PLA', '880016.PLA', '880017.PLA', '880018.PLA', '880019.PLA', '880020.PLA', '880021.PLA', '880022.PLA', '880023.PLA', '880024.PLA', '880025.PLA', '880026.PLA', '880027.PLA', '880028.PLA', '880029.PLA', '880030.PLA', '880031.PLA', '880033.PLA', '880035.PLA', '880039.PLA', '880041.PLA', '880042.PLA', '880043.PLA', '880044.PLA', '880045.PLA', '880046.PLA', '880047.PLA', '880048.PLA', '880049.PLA', '880050.PLA', '880051.PLA', '880052.PLA', '880053.PLA', '880056.PLA', '880057.PLA', '880058.PLA', '880059.PLA', '880060.PLA', '880064.PLA', '880065.PLA'] getContinuousSymbol-获取指定交易日连续/主力等合约对应的合约代码 函数原型： getContinuousSymbol (maincfs,tradeDate) 传入连续/主力合约名称，获取对应的实际的标准合约代码。期货专用。 参数： 参数 类型 是否必填 说明 maincfs str 是 连续合约的代码，包括主力、次主力合约，当月、次月、下季、隔季连续合约 tradeDate int 否 指定某个交易日，不填则默认为回测当天。形式为YYYYMMDD 返回：对应的期货合约代码。 举例： 获取主力合约在某交易日对应的标准合约 api.getContinuousSymbol (maincfs=\"jmZ0.CF\", tradeDate=20180820) 返回结果： jm1901.CF 获取当月合约在某交易日对应的标准合约 api.getContinuousSymbol (maincfs=\"IFM0.CF\", tradeDate=20180820) 返回结果： IF1809.CF getFieldsOneDay-获取多只股票单个交易日的数据 获取股票的股本、市值等信息，主要是日频和部分季频因子数据。数据信息详见股票交易指标-日频和股票财务数据-季频。 调用此api之前需在初始化onInitialize中setRequireData中设置所需股票和对应属性字段，不然取不到数据 函数原型 getFieldsOneDay(symbols, fields=None,tradeDate,df = True) 参数： 参数 类型 是否必填 说明 symbols str or list 是 股票或者股票列表 fields str or list 是 选取的股票属性，可以选择多个 tradeDate int 否 指定某个交易日，不填则默认为回测上一交易日。形式为YYYYMMDD df bool 否 返回是否采用dataFrame格式，默认为True 返回：df为True时返回dataFrame格式，df为False时返回dict类型。 举例： 获取多只标的在某交易日的金融数据 #首先在def onInitialize(api)中设置缓存数据 api.setRequireData(instsets=[],symbols=[\"000002.CS\", \"600000.CS\"], fields=[\"PE\", \"TRADE_STA\"], bars=[(ETimeSpan.DAY_1,20)]) #设置股票池，缓存要获取的因子,设置要取的因子数据为前20个交易日以内 #在对应的事件回调中调用api获取数据。对于日频因子，获取的某一交易日一定要在准备的日K条数之内，否则获取不到值。在onBeforeMarketOpen中调用如下： data = api.getFieldsOneDay([\"000002.CS\", \"600000.CS\"], fields =[\"PE\", \"TRADE_STA\"], tradeDate =20181122,df =True ) 返回结果： PE TRADE_STA symbol tradeDate 0 5.6400 True 000002.CS 20181122 1 5.5501 True 600000.CS 20181122 getFieldsRangeDays-获取单只股票多个交易日的数据 获取一只股票多个交易日的股本、市值等信息。数据信息详见股票交易指标-日频和股票财务数据-季频。 调用此api之前需在初始化onInitialize中setRequireData中设置所需股票和对应属性字段，不然取不到数据。 函数原型 getFieldsRangeDays(symbol,fields,startDate ,endDate,df=True) 参数： 参数 类型 是否必填 说明 symbol str 是 股票代码 fields str or list 是 选取的股票属性，可以选择多个 startDate int 是 指定取数据的开始时间,YYYYMMDD endDate int 否 指定取数据的结束时间，不填默认返回上一交易日，YYYYMMDD df bool 否 返回是否采用dataFrame格式，默认为True 返回： pandas DataFrame 举例： 获取某标的在一段时间内的因子数据 #首先在def onInitialize(api)中设置缓存数据 api.setRequireData(instsets=[],symbols=[\"000001.CS\"] , fields=[\"PE\",\"REVENUE\",\"TRADE_STA\", \"TOT_SHARE\", \"LIST_STA\"], bars=[(ETimeSpan.DAY_1,20)]) #在对应的事件回调中调用api获取数据。对于日频因子，获取的交易日开始日期一定要在准备的日K条数之内，否则会获取到空值。在onBeforeMarketOpen中调用如下： data = api.getFieldsRangeDays(symbol=\"000001.CS\",fields = [\"PE\",\"REVENUE\",\"TRADE_STA\", \"TOT_SHARE\", \"LIST_STA\"],startDate=20181116, endDate=20181120,df=True) 返回结果： LIST_STA PE REVENUE TOT_SHARE TRADE_STA symbol tradeDate 0 1 7.4102 8.666400e+10 1.717041e+10 True 000001.CS 20181116 1 1 7.6065 8.666400e+10 1.717041e+10 True 000001.CS 20181119 2 1 7.4102 8.666400e+10 1.717041e+10 True 000001.CS 20181120 获取字段值 TOT_SHARE=date.ix[0:1,[\"REVENUE\",\"PE\"]] #获取前两行的\"REVENUE\",\"PE\"字段值 返回结果： REVENUE PE 0 8.666400e+10 7.4102 1 8.666400e+10 7.6065 getFieldsCountDays-获取单只股票基于某个交易日的前n条数据 获取单只股票基于某个交易日的前n条股本、市值等数据。数据信息详见股票交易指标-日频和股票财务数据-季频。 调用此api之前需在初始化onInitialize中setRequireData中设置所需股票和对应属性字段，不然取不到数据。 函数原型 getFieldsCountDays(symbol, fields=None, tradeDate=None, count=1, df=True) 参数： 参数 类型 是否必填 说明 symbol str 是 股票代码 fields str or list 是 选取的股票属性，可以选择多个 count int 是 获取基于所传交易日往前推的N条数据（包含所传交易日当天） tradeDate int 否 交易日，不填按默认返回上一交易日，形式为YYYYMMDD df bool 否 返回是否采用dataFrame格式，默认为True 返回： pandas DataFrame 举例： 获取基于某交易日往前推的两条数据，格式为dataFrame #首先在def onInitialize(api)中设置缓存数据 api.setRequireData(instsets=[],symbols=[\"000001.CS\"], fields=[\"TOT_SHARE\",\"BASIC_EPS\", \"PE\"], bars=[(ETimeSpan.DAY_1,20)]) #然后在对应的事件回调中调用api获取数据。对于日频因子，获取的数据一定要在准备的日K条数之内，否则会获取到空值。在onBeforeMarketOpen中调用如下： datas = api.getFieldsCountDays(symbol=\"000001.CS\", fields=[\"TOT_SHARE\", \"BASIC_EPS\", \"PE\"], tradeDate=20181122, count=2) 返回结果： BASIC_EPS PE TOT_SHARE symbol tradeDate 0 1.14 7.4383 1.717041e+10 000001.CS 20181121 1 1.14 7.3962 1.717041e+10 000001.CS 20181122 获取上一交易日往前推的两条数据，当前交易日为20181126，格式为dataFrame。在onBeforeMarketOpen中调用如下： datas = api.getFieldsCountDays(symbol=\"000001.CS\", fields=[\"TOT_SHARE\", \"BASIC_EPS\", \"PE\"], count=2) 返回结果： BASIC_EPS PE TOT_SHARE symbol tradeDate 0 1.14 7.3962 1.717041e+10 000001.CS 20181122 1 1.14 7.2350 1.717041e+10 000001.CS 20181123 getStockFinFields-获取财务数据 获取股票的财务数据。数据信息详见股票财务数据-季频。 调用此api之前需在初始化onInitialize中setSymbolPool设置相关股票池，然后在setRequireFields中设置所需字段，不然取不到字段值 函数原型 getStockFinFields(symbols,fields,tradeDate=None,report = None,df = True) 参数： 参数 类型 是否必填 说明 symbols str 是 股票代码或列表 fields str or list 是 选取的股票属性，可以选择多个 tradeDate int 否 交易日，形式为YYYYMMDD，为了避免未来函数只能获取到所传交易日之前的数据，不填默认返回上一交易日 report str 否 指定报告期，例如'2016Q1' - 16年一季报，'2016Q2' - 16年半年报，'2016Q3' - 16年三季报，'2016Q4'-年报，report缺省时返回标的最新的报告期数据。 df boo 否 返回是否采用dataFrame格式，默认为True 举例： 获取000001.CS的2016年年报数据，当前交易日为20181126 #首先在def onInitialize(api)中设置缓存数据 api.setSymbolPool(instsets=[],symbols=[\"000001.CS\"])#设置股票池 api.setRequireFields(fields=[\"REVENUE\", \"NET_PROFIT\", \"NET_PROFIT_ATTRP\"]）#缓存要获取的因子 #然后在对应的事件回调中调用api获取数据。在onBeforeMarketOpen中调用如下： data = api.getStockFinFields(symbols=\"000001.CS\",fields = [\"REVENUE\", \"NET_PROFIT\", \"NET_PROFIT_ATTRP\"], tradeDate = 20170505,report=\"2016Q4\") 返回结果： NET_PROFIT NET_PROFIT_ATTRP REVENUE reportdate symbol tradeDate 0 2.259900e+10 2.259900e+10 1.077150e+11 20161231 000001.CS 20170505 getTableFieldOneDay-获取单标的某一交易日的表格型数据 获取单只标单个交易日的表格型数据，数据信息详见表格型数据 调用此api之前需在初始化onInitialize里setRequireData中设置所需股票和对应属性字段，不然取不到数据。 函数原型： getTableFieldOneDay( symbol, field, tradeDate=None, columns=None, df = True) 参数： 参数 类型 是否必填 说明 symbol str 是 股票代码 field str 是 表格名 ，详见表格型数据 tradeDate int 否 指定某个交易日，不填则默认为回测上一交易日。形式为YYYYMMDD columns list 否 返回的字段；为空时,默认返回所有列,否则返回指定的列 df bool 否 返回是否采用dataFrame格式，默认为True 举例： 获取a1901.CF上一交易日成交量排名列表 #首先在def onInitialize(api)中设置缓存数据 api.setRequireData(instsets=[],symbols=[\"a1901.CF\"], fields=[ 'FUT_TRADE_RANK'], bars=[(ETimeSpan.DAY_1,20)]) #然后在对应的事件回调中调用api获取数据。对于日频因子，获取的数据一定要在准备的日K条数之内，否则会获取到空值。在onBeforeMarketOpen中调用如下： api.getTableFieldOneDay(symbol =\"a1901.CF\",field= 'FUT_TRADE_RANK', tradeDate =20181120,columns=['rank', 'name', 'volume', 'volumeDiff'], df=True) 返回结果： name rank tradeDate volume volumeDiff 0 东证期货 1 20181120 14924.0 6320.0 1 中信期货 2 20181120 14329.0 5721.0 2 海通期货 3 20181120 7742.0 1050.0 3 国泰君安 4 20181120 7029.0 1654.0 4 华泰期货 5 20181120 6147.0 2323.0 5 华安期货 6 20181120 5279.0 -899.0 6 兴证期货 7 20181120 4901.0 -151.0 7 徽商期货 8 20181120 4615.0 1769.0 8 国投安信 9 20181120 4519.0 -343.0 9 方正中期 10 20181120 4003.0 207.0 10 光大期货 11 20181120 3771.0 1155.0 11 国信期货 12 20181120 3698.0 -2126.0 12 永安期货 13 20181120 3457.0 379.0 13 创元期货 14 20181120 3200.0 1742.0 14 中信建投 15 20181120 3096.0 1776.0 15 银河期货 16 20181120 3059.0 543.0 16 广发期货 17 20181120 2804.0 438.0 17 南华期货 18 20181120 2392.0 -231.0 18 渤海期货 19 20181120 2318.0 1766.0 19 上海大陆 20 20181120 2245.0 1813.0 获取申万一级行业板块的K线数据 #先在def onInitialize(api):中设置股票池、缓存要获取的因子和K线条数： api.setRequireData(instsets=[],symbols=['801780.PLA'], fields=[ \"SW_MKT\"], bars=[(ETimeSpan.DAY_1,20)]) #然后在对应的事件回调中调用api获取数据。对于日频因子，获取的数据一定要在准备的日K条数之内，否则会获取到空值。在onBeforeMarketOpen中调用如下： api.getTableFieldOneDay('801780.PLA', 'SW_MKT', 20181122, df=True) 返回结果： close high low open preClose totalTurnover totalVolume tradeDate 0 3302.34 3320.06 3291.49 3320.06 3314.79 752355335.0 5.570303e+09 20181122 getTableFieldRangeDays-获取单标的多个交易日的表格型数据 获取单标的多个交易日的表格型数据，获取的ttype与getTableFieldOneDay相同。 调用此api之前需在初始化onInitialize里setRequireData中设置所需股票和对应属性字段，不然取不到数据。 函数原型： 　getTableFieldRangeDays( symbol, field, startDate, endDate=None, columns=None, df = True) 参数： 参数 类型 是否必填 说明 symbol str 是 股票代码 field str 是 表格名 ，详见表格型数据 startDate int 是 指定取数据的开始时间,YYYYMMDD endDate int 否 指定取数据的结束时间，不填默认返回上一交易日，YYYYMMDD columns list 否 返回的字段；为空时,默认返回所有列,否则返回指定的列 df bool 否 返回是否采用dataFrame格式，默认为True 举例： 获取a1901.CF多个交易日的成交量排名列表 #首先在def onInitialize(api)中设置缓存数据 api.setRequireData(instsets=[],symbols=[\"a1901.CF\"], fields=[ 'FUT_TRADE_RANK'], bars=[(ETimeSpan.DAY_1, 20)]) #然后在对应的事件回调中调用api获取数据。对于日频因子，获取的数据一定要在准备的日K条数之内，否则会获取到空值。在onBeforeMarketOpen中调用如下： api.getTableFieldRangeDays(symbol =\"a1901.CF\",field= 'FUT_TRADE_RANK',startDate=20181122,endDate =20181124,columns=['rank', 'name', 'volume', 'volumeDiff'], df=True) 返回结果为： name rank tradeDate volume volumeDiff 0 东证期货 1 20181122 8705.0 -4422.0 1 中信期货 2 20181122 7001.0 -6352.0 2 国泰君安 3 20181122 5417.0 -1273.0 3 海通期货 4 20181122 4833.0 -3542.0 4 方正中期 5 20181122 4043.0 -619.0 5 华泰期货 6 20181122 3838.0 -2074.0 6 国信期货 7 20181122 3259.0 -308.0 7 徽商期货 8 20181122 3174.0 173.0 8 渤海期货 9 20181122 3116.0 1557.0 9 兴证期货 10 20181122 2990.0 -2049.0 10 华安期货 11 20181122 2890.0 -479.0 11 中信建投 12 20181122 2825.0 512.0 12 永安期货 13 20181122 2526.0 339.0 13 光大期货 14 20181122 2249.0 -1020.0 14 国投安信 15 20181122 2027.0 -1504.0 15 南华期货 16 20181122 2024.0 183.0 16 银河期货 17 20181122 1640.0 -1070.0 17 东航期货 18 20181122 1587.0 -132.0 18 浙商期货 19 20181122 1570.0 273.0 19 安粮期货 20 20181122 1386.0 -171.0 20 东证期货 1 20181123 16670.0 7965.0 21 中信期货 2 20181123 12174.0 5173.0 22 国泰君安 3 20181123 11408.0 5991.0 23 海通期货 4 20181123 8317.0 3484.0 24 华泰期货 5 20181123 7781.0 3943.0 25 方正中期 6 20181123 6921.0 2878.0 26 华安期货 7 20181123 6349.0 3459.0 27 徽商期货 8 20181123 5378.0 2204.0 28 国信期货 9 20181123 5031.0 1772.0 29 兴证期货 10 20181123 4877.0 1887.0 30 光大期货 11 20181123 4499.0 2250.0 31 国投安信 12 20181123 4174.0 2147.0 32 中信建投 13 20181123 3563.0 738.0 33 大有期货 14 20181123 3199.0 1939.0 34 渤海期货 15 20181123 3125.0 9.0 35 永安期货 16 20181123 2979.0 453.0 36 银河期货 17 20181123 2870.0 1230.0 37 宏源期货 18 20181123 2575.0 1276.0 38 东航期货 19 20181123 2250.0 663.0 39 广发期货 20 20181123 2040.0 729.0 获取申万一级行业板块多个交易日的K线数据 #首先在def onInitialize(api):中设置股票池、缓存要获取的因子和K线条数： api.setRequireData(instsets=[],symbols=['801010.PLA'], fields=[ \"SW_MKT\"], bars=[(ETimeSpan.DAY_1,20)]) #然后在对应的事件回调中调用api获取数据。对于日频因子，获取的数据一定要在准备的日K条数之内，否则会获取到空值。在onBeforeMarketOpen中调用如下： api.getTableFieldRangeDays( '801010.PLA', \"SW_MKT\", 20181122,20181123, columns=None, df = True) 返回结果为： close high low open preClose totalTurnover totalVolume tradeDate 0 2272.95 2293.86 2264.67 2289.74 2286.45 8.149344e+08 5.235480e+09 20181122 1 2230.37 2276.36 2222.91 2276.36 2272.95 1.033341e+09 6.586772e+09 20181123 getTableFieldCountDays-获取单标的多条表格型数据 获取单标的多条表格型数据，获取的type与getTableFieldOneDay相同。 调用此api之前需在初始化onInitialize中setRequireData设置股票和所需表格型数据 ，不然取不到字段值 函数原型： 　　getTableFieldCountDays( symbol, field, tradeDate=None, count=None, columns=None, df = True) 参数： 参数 类型 是否必填 说明 symbol str 是 股票代码 field str 是 表格名 ，详见表格型数据 tradeDate int 否 指定取数据的开始时间,不填默认返回上一交易日，YYYYMMDD count int 是 获取基于所传交易日往前推的N条数据（包含所传交易日当天） columns list 否 返回的字段；为空时,默认返回所有列,否则返回指定的列 df bool 否 返回是否采用dataFrame格式，默认为True 举例： 获取a1901.CF多个交易日成交量排名列表 #首先在def onInitialize(api)中设置缓存数据 api.setRequireData(instsets=[], symbols=[\"a1901.CF\"], fields=['FUT_TRADE_RANK'], bars=[(ETimeSpan.DAY_1, 20)]) #然后在对应的事件回调中调用api获取数据。对于日频因子，获取的数据一定要在准备的日K条数之内，否则会获取到空值。在onBeforeMarketOpen中调用如下： #获取a1901基于当前交易日（20181122）往前推共2个交易日的成交排名列表 api.getTableFieldCountDays(symbol=\"a1901.CF\", field='FUT_TRADE_RANK',tradeDate=20181122, count=2, columns=['rank', 'name', 'volume', 'volumeDiff'], df=True) 返回结果为： name rank tradeDate volume volumeDiff 0 中信期货 1 20181121 13353.0 -976.0 1 东证期货 2 20181121 13127.0 -1797.0 2 海通期货 3 20181121 8375.0 633.0 3 国泰君安 4 20181121 6690.0 -339.0 4 华泰期货 5 20181121 5912.0 -235.0 5 兴证期货 6 20181121 5039.0 138.0 6 方正中期 7 20181121 4662.0 659.0 7 国信期货 8 20181121 3567.0 -131.0 8 国投安信 9 20181121 3531.0 -988.0 9 华安期货 10 20181121 3369.0 -1910.0 10 光大期货 11 20181121 3269.0 -502.0 11 徽商期货 12 20181121 3001.0 -1614.0 12 银河期货 13 20181121 2710.0 -349.0 13 广发期货 14 20181121 2680.0 -124.0 14 中信建投 15 20181121 2313.0 -783.0 15 永安期货 16 20181121 2187.0 -1270.0 16 南华期货 17 20181121 1841.0 -551.0 17 东航期货 18 20181121 1719.0 -355.0 18 弘业期货 19 20181121 1676.0 643.0 19 大有期货 20 20181121 1673.0 -296.0 20 东证期货 1 20181122 8705.0 -4422.0 21 中信期货 2 20181122 7001.0 -6352.0 22 国泰君安 3 20181122 5417.0 -1273.0 23 海通期货 4 20181122 4833.0 -3542.0 24 方正中期 5 20181122 4043.0 -619.0 25 华泰期货 6 20181122 3838.0 -2074.0 26 国信期货 7 20181122 3259.0 -308.0 27 徽商期货 8 20181122 3174.0 173.0 28 渤海期货 9 20181122 3116.0 1557.0 29 兴证期货 10 20181122 2990.0 -2049.0 30 华安期货 11 20181122 2890.0 -479.0 31 中信建投 12 20181122 2825.0 512.0 32 永安期货 13 20181122 2526.0 339.0 33 光大期货 14 20181122 2249.0 -1020.0 34 国投安信 15 20181122 2027.0 -1504.0 35 南华期货 16 20181122 2024.0 183.0 36 银河期货 17 20181122 1640.0 -1070.0 37 东航期货 18 20181122 1587.0 -132.0 38 浙商期货 19 20181122 1570.0 273.0 39 安粮期货 20 20181122 1386.0 -171.0 获取申万一级行业板块多个交易日的K线数据 #首先在def onInitialize(api):中设置股票池、缓存要获取的因子和K线条数： api.setRequireData(instsets=[],symbols=['801010.PLA'], fields=[ \"SW_MKT\"], bars=[(ETimeSpan.DAY_1,20)]) #然后在对应的事件回调中调用api获取数据。对于日频因子，获取的数据一定要在准备的日K条数之内，否则会获取到空值。在onBeforeMarketOpen中调用如下： api.getTableFieldCountDays(symbol='801010.PLA',field=\"SW_MKT\",tradeDate= 20181122,count=3, columns=None, df = True) 返回结果如下： close high low open preClose totalTurnover totalVolume tradeDate 0 2263.10 2312.21 2261.69 2307.56 2320.63 1.143088e+09 7.398032e+09 20181120 1 2286.45 2288.83 2240.66 2251.17 2263.10 1.015610e+09 6.188521e+09 20181121 2 2272.95 2293.86 2264.67 2289.74 2286.45 8.149344e+08 5.235480e+09 20181122 getTradeDayInterval-获取交易日数 获取某时间区间交易日数，起止时间只能是回测区间内的 函数原型： getTradeDayInterval（symbol, startDate,endDate） 参数： 参数 类型 是否必填 说明 symbol str 是 标的代码 startDate int 是 开始时间，格式为YYMMDD endDate int 是 结束时间，格式为YYMMDD 返回值：返回值为交易日数 举例： 获取一段时间内的交易日数，包含所传起止日期 data = api.getTradeDayInterval(symbol=\"000002.CS\",startDate= 20151217, endDate=20160704) 返回结果： 3 (注：该结果过滤了万科A在这段时间内的停牌） getPrevTradeDate-获取上一个交易日期 获取上一个交易日期 函数原型： getPrevTradeDate(tradeDate，mktIndex=none) 参数： 参数 类型 是否必填 说明 tradeDate int 是 交易日，格式为YYMMDD mktIndex str 否 市场代码，不填默认返回A股市场的交易日 返回值：返回上一交易日的日期 举例： api.getPrevTradeDate(tradeDate=20150101) #返回值为20141231 api.getPrevTradeDate(tradeDate=20150101,mktIndex=\"CS\") #返回值为20141231 getNextTradeDate-获取下一个交易日期 获取下一个交易日期 函数原型： getNextTradeDate(tradeDate，mktIndex=none) 参数： 参数 类型 是否必填 说明 tradeDate int 是 开始时间，格式为YYMMDD mktIndex str 否 市场代码，不填默认返回A股市场的交易日 返回值：返回下一交易日的日期 举例： api.getNextTradeDate(tradeDate =20150101) #返回值为20150105 api.getNextTradeDate(tradeDate =20150101,mktIndex=\"CS\") #返回值为20150105 getTradeDates-获取一段时间内交易日期 指定起止日期，获取某个市场一段时间的交易日期 函数原型： getTradeDates（startDate,endDate,mktIndex = None） 参数： 参数 类型 是否必填 说明 startDate date 是 开始时间（含当天），格式为YYMMDD endDate date 是 结束时间（含当天），格式为YYMMDD mktIndex str or list 否 交易市场,不填默认返回A股市场的交易日 返回值：交易日list，日期格式YYYMMDD，类型为int 举例： 获取一段时间内的交易日期，包含所传起止日期 api.getTradeDates(startDate =20171001, endDate =20171011) 返回结果： [20171009, 20171010, 20171011] getPrevTradeDates-获取某个市场截止指定日期的多个交易日期 指定截止日期，返回某个市场指定天数的交易日期 函数原型： getPrevTradeDates(tradeDate, count, mktIndex=None) 参数： 参数 类型 是否必填 说明 tradeDate date 是 截止日期（含当天），格式为YYMMDD count int 是 返回天数（含当天），count需大于0 mktIndex str or list 否 交易市场,不填默认返回A股市场的交易日 返回值：交易日list，日期格式YYYMMDD，类型为int 举例： api.getPrevTradeDates(20181008,7)#返回A股市场截止20181008日7个交易日日期 返回结果 [20180920, 20180921, 20180925, 20180926, 20180927, 20180928, 20181008] isSuspend-是否停牌 判断标的当日是否停牌 函数原型： isSuspend(symbol,tradeDate) 参数： 参数 类型 是否必填 说明 symbol str 是 策略中的证券代码 tradeDate int 否 交易日，形式为YYYYMMDD，可以查询历史上的状态，不填默认返回当天的数据 返回值：返回True表示停牌，返回False表示未停牌 举例： isSuspend = api.isSuspend(symbol =\"000001.CS\",tradeDate =20180104)#获取000001.CS在20180104是否停牌 isST-是否ST股 判断标的当日是否ST股 函数原型： isST(symbol,tradeDate） 参数： 参数 类型 是否必填 说明 symbol str 是 策略中的证券代码 tradeDate int 否 交易日，形式为YYYYMMDD，可以查询历史上的状态，不填默认返回当天的数据 返回值：返回True表示ST股，返回False表示非ST股 举例： isST = api.isST(symbol =\"000001.CS\",tradeDate =20180104)#获取000001.CS在20180104是否ST isListed-是否上市 判断标的当日是否上市 函数原型： isListed(symbol,tradeDate） 参数： 参数 类型 是否必填 说明 symbol str 是 策略中的证券代码 tradeDate int 否 交易日，形式为YYYYMMDD，可以查询历史上的状态，不填默认返回当天的数据 返回值：返回True表示上市，返回False表示未上市或者已退市 举例： isListed = api.isListed(symbol =\"000001.CS\",tradeDate =20180104)#获取000001.CS在20180104是否上市 其他函数 getDefineData-获取命令行参数 函数原型： getDefineData(name, default_value, etype) 参数： 参数 类型 是否必填 说明 name str 是 命令行传入的名称 default_value etype 否 默认值为空，类型和etype一致 etype type 是 类型，有str、int等 举例： 在命令行输入如下命令 python main.py --name=upchina --value=20，在策略里可以通过api.getDefineData()获取，形式如下： api.getDefineData(name='name', default_value='myname', etype=str) api.getDefineData(name='value', default_value=0, etype=int) 上一个结果会获取到'upchina' 下一个结果获取到20 示例： 为了能动态的调整策略参数，可以通过命令行传入参数值，举例如下： 新建策略文件example.py，通过N条历史K线的收盘价的平均值和当前收盘价作比较进行下单，运行结束后调用onTerminate事件，将结果存储于result.txt文件中，代码如下： #!/usr/bin/env python # -*- coding: utf-8 -*- #回测周期为20180702-20180719 from etasdk import * import time from datetime import datetime def onInitialize(api): print(\"onInitialize\") #获取命令行参数 api.bar_len = api.getDefineData('bar_len', 10, int) api.setRequireData( symbols=['000001.CS'], fields=[\"TOT_SHARE\", \"SP_RESER\", \"PE\"], bars=[ (ETimeSpan.DAY_1, api.bar_len) ] ) def onBeforeMarketOpen(api, data): print(\"time----\",data) symbolPool = api.getSymbolPool() api.setFocusSymbols(symbolPool) def onBar(api, bar): print(\"onbar: %d\"%bar.tradeDate) hisBar=api.getBarsHistory(bar.symbol, ETimeSpan.DAY_1, api.bar_len, skipSuspended=1, df=True,priceMode = EPriceMode.FORMER) close=hisBar[\"close\"].mean() current_price = hisBar[\"close\"][api.bar_len-1] print close,current_price,bar.close cash = api.getAccount(bar.symbol).cashAvailable qty = int(0.8 * cash / current_price / 100) * 100 if current_price > close: api.targetPosition(bar.symbol, qty) def onTerminate(api, exit_info): LOG.INFO(\"onTerminate\") print(exit_info) #存储结果 line = str(api.bar_len) + ':' line += str(exit_info.sharpeRatio) + ',' + str(exit_info.maximumDrawdown) + ',' + str(exit_info.annualizedReturn) line += '\\n' file = r'./result.txt' with open(file, 'a+') as f: f.write(line) 创建一个用于批处理的文件batch.py，代码如下： #!/usr/bin/env python # -*- coding: utf-8 -*- import subprocess # 调参, 来优化策略的参数 n_bar_lenth = [i for i in range(10, 20, 2)] for l in n_bar_lenth: args = ' --bar_len=' + str(l) print args status = subprocess.call(\"python main.py\" + args, shell=True) #运行会循环bar_len, 动态调整参数, 调用策略, 并在策略中保存最后的结果 通过运行batch.py文件，会循环调用main.py，K线条数分别是10、12、14、16、18，循环运行五次结果会存储在result.txt文件中，例子结果如下： 10:-7.80182813879,0.63050232,-20.2195962497 12:-7.80182813879,0.63050232,-20.2195962497 14:0.0,0.0,0.0 16:0.0,0.0,0.0 18:0.0,0.0,0.0 通过对比几次运行结果的数据，来选择最优的参数，以上举例仅供参考。 LOG.*-日志输出 函数原型： LOG.DEBUG(logstr) #DEBUG级别日志 LOG.INFO(logstr) #INFO级别日志 LOG.ERROR(logstr) #ERROR级别日志 参数： 参数 类型 说明 logstr str 日志内容 返回值：日志打印的内容 举例： 日志打印的级别与config配置中的\"loglevel\"级别一一对应，即loglevel为info就调用LOG.INFO，loglevel为error就调用LOG.ERROR输出日志。 prev= api.getPrevTradeDate(tradeDate) #获取上一交易日 curr=api.getCurrTradeDate() #获取当前交易日 LOG.INFO(\"current tradedate %s,last tradedate %s\" ,curr,prev) #打印当前交易日和上一交易日 LOG.INFO(\"current tradedate = %s \", curr) #打印当前交易日 策略打印日志注意事项： 1、尽量不要print中文，不同的python环境，print中文后，有可能出现莫名其妙的问题 2、选股、下单等依据数据的关键数据点，要用 LOG.INFO 输出日志，这样模拟盘会把日志输出到algo.python_main.log 这个文件里，回测的时候不会输出，因为回测日志级别默认是error，如果回测也想打印日志可以用LOG.ERROR或者将config中的日志级别改成info（后者会影响回测速度）； 3、更重要的数据，可以调用 api.sendCustomMsg 把日志信息输出到 web平台上，但是这个接口不要调用太多，有性能问题 sendCustomMsg-设置用户自定义运行消息 设置用户自定义运行消息，会显示在界面上的日志中 函数原型： sendCustomMsg(msgstr) 参数： 参数 类型 说明 msgstr str 内容 返回值：Web端日志显示需要显示的信息 举例： api.sendCustomMsg(str(\"focus symbol:\"+\";\".join(code_))) #Web端日志中显示关注股票 返回值： 2019-01-25 08:30:03 795 - INFO - focus symbol:002075.CS;300003.CS;000963.CS;002798.CS isTradingNow-标的当前时间是否为交易时间 对于股票交易时间为每个交易日9:30-11:30，13:00-15:00；但是对于期货、外汇等不同标的交易时间并不一致。 函数原型： isTradingNow (symbol) 参数： 参数 类型 是否必填 说明 symbol str 是 标的代码 返回值：当前是否交易，bool类型。 举例： istradingnow = api.isTradingNow (symbol =\"000001.CS\") #获取000001.CS是否交易 timeNow-获取时间 函数原型： timeNow () 参数：无 返回值：当前行情时间戳,int类型,单位毫秒。 举例：ms=api.timeNow () "}}